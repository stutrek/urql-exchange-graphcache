{"version":3,"file":"urql-exchange-graphcache.es.js","sources":["../src/ast/node.ts","../src/helpers/help.ts","../src/store/keys.ts","../src/store/timing.ts","../src/store/data.ts","../src/operations/shared.ts","../src/operations/write.ts","../src/operations/invalidate.ts","../src/store/store.ts","../src/ast/variables.ts","../src/ast/schemaPredicates.ts","../src/ast/traversal.ts","../src/operations/query.ts","../src/cacheExchange.ts","../src/populateExchange.ts"],"sourcesContent":["import {\n  NamedTypeNode,\n  NameNode,\n  SelectionNode,\n  SelectionSetNode,\n  InlineFragmentNode,\n  FieldNode,\n  FragmentDefinitionNode,\n  GraphQLOutputType,\n  Kind,\n  isWrappingType,\n} from 'graphql';\n\nimport { SelectionSet, GraphQLFlatType } from '../types';\n\n/** Returns the name of a given node */\nexport const getName = (node: { name: NameNode }): string => node.name.value;\n\nexport const getFragmentTypeName = (node: FragmentDefinitionNode): string =>\n  node.typeCondition.name.value;\n\n/** Returns either the field's name or the field's alias */\nexport const getFieldAlias = (node: FieldNode): string =>\n  node.alias !== undefined ? node.alias.value : getName(node);\n\n/** Returns the SelectionSet for a given inline or defined fragment node */\nexport const getSelectionSet = (node: {\n  selectionSet?: SelectionSetNode;\n}): SelectionSet =>\n  node.selectionSet !== undefined ? node.selectionSet.selections : [];\n\nexport const getTypeCondition = ({\n  typeCondition,\n}: {\n  typeCondition?: NamedTypeNode;\n}): string | null =>\n  typeCondition !== undefined ? getName(typeCondition) : null;\n\nexport const isFieldNode = (node: SelectionNode): node is FieldNode =>\n  node.kind === Kind.FIELD;\n\nexport const isInlineFragment = (\n  node: SelectionNode\n): node is InlineFragmentNode => node.kind === Kind.INLINE_FRAGMENT;\n\nexport const unwrapType = (\n  type: null | undefined | GraphQLOutputType\n): GraphQLFlatType | null => {\n  if (isWrappingType(type)) {\n    return unwrapType(type.ofType);\n  }\n\n  return type || null;\n};\n","// These are guards that are used throughout the codebase to warn or error on\n// unexpected behaviour or conditions.\n// Every warning and error comes with a number that uniquely identifies them.\n// You can read more about the messages themselves in `docs/help.md`\n\nimport { Kind, ExecutableDefinitionNode, InlineFragmentNode } from 'graphql';\nimport { ErrorCode } from '../types';\n\ntype DebugNode = ExecutableDefinitionNode | InlineFragmentNode;\n\nconst helpUrl =\n  '\\nhttps://github.com/FormidableLabs/urql-exchange-graphcache/blob/master/docs/help.md#';\nconst cache = new Set<string>();\n\nexport const currentDebugStack: string[] = [];\n\nexport const pushDebugNode = (typename: void | string, node: DebugNode) => {\n  let identifier = '';\n  if (node.kind === Kind.INLINE_FRAGMENT) {\n    identifier = typename\n      ? `Inline Fragment on \"${typename}\"`\n      : 'Inline Fragment';\n  } else if (node.kind === Kind.OPERATION_DEFINITION) {\n    const name = node.name ? `\"${node.name.value}\"` : 'Unnamed';\n    identifier = `${name} ${node.operation}`;\n  } else if (node.kind === Kind.FRAGMENT_DEFINITION) {\n    identifier = `\"${node.name.value}\" Fragment`;\n  }\n\n  if (identifier) {\n    currentDebugStack.push(identifier);\n  }\n};\n\nconst getDebugOutput = (): string =>\n  currentDebugStack.length\n    ? '\\n(Caused At: ' + currentDebugStack.join(', ') + ')'\n    : '';\n\nexport function invariant(\n  condition: any,\n  message: string,\n  code: ErrorCode\n): asserts condition {\n  if (!condition) {\n    let errorMessage = message || 'Minfied Error #' + code + '\\n';\n    if (process.env.NODE_ENV !== 'production') {\n      errorMessage += getDebugOutput();\n    }\n\n    const error = new Error(errorMessage + helpUrl + code);\n    error.name = 'Graphcache Error';\n    throw error;\n  }\n}\n\nexport function warn(message: string, code: ErrorCode) {\n  if (!cache.has(message)) {\n    console.warn(message + getDebugOutput() + helpUrl + code);\n    cache.add(message);\n  }\n}\n","import { stringifyVariables } from 'urql/core';\nimport { Variables, FieldInfo } from '../types';\n\nexport const keyOfField = (fieldName: string, args?: null | Variables) =>\n  args ? `${fieldName}(${stringifyVariables(args)})` : fieldName;\n\nexport const fieldInfoOfKey = (fieldKey: string): FieldInfo => {\n  const parenIndex = fieldKey.indexOf('(');\n  if (parenIndex > -1) {\n    return {\n      fieldKey,\n      fieldName: fieldKey.slice(0, parenIndex),\n      arguments: JSON.parse(fieldKey.slice(parenIndex + 1, -1)),\n    };\n  } else {\n    return {\n      fieldKey,\n      fieldName: fieldKey,\n      arguments: null,\n    };\n  }\n};\n\nexport const joinKeys = (parentKey: string, key: string) =>\n  `${parentKey}.${key}`;\n\n/** Prefix key with its owner type Link / Record */\nexport const prefixKey = (owner: 'l' | 'r', key: string) => `${owner}|${key}`;\n","export const defer: (fn: () => void) => void =\n  process.env.NODE_ENV === 'production' && typeof Promise !== 'undefined'\n    ? Promise.prototype.then.bind(Promise.resolve())\n    : fn => setTimeout(fn, 0);\n","import {\n  Link,\n  EntityField,\n  FieldInfo,\n  StorageAdapter,\n  SerializedEntries,\n} from '../types';\nimport { invariant, currentDebugStack } from '../helpers/help';\nimport { fieldInfoOfKey, joinKeys, prefixKey } from './keys';\nimport { defer } from './timing';\n\nimport { observable, action } from 'mobx';\n\ntype Dict<T> = Record<string, T>;\ntype KeyMap<T> = Map<string, T>;\ntype OptimisticMap<T> = Record<number, T>;\n\ninterface NodeMap<T> {\n  optimistic: OptimisticMap<KeyMap<Dict<T | undefined>>>;\n  base: KeyMap<Dict<T>>;\n  keys: number[];\n}\n\nexport interface InMemoryData {\n  persistenceScheduled: boolean;\n  persistenceBatch: SerializedEntries;\n  gcScheduled: boolean;\n  gcBatch: Set<string>;\n  queryRootKey: string;\n  refCount: Dict<number>;\n  refLock: OptimisticMap<Dict<number>>;\n  records: NodeMap<EntityField>;\n  links: NodeMap<Link>;\n  storage: StorageAdapter | null;\n}\n\nexport const makeDict = (): any => observable({});\n\nlet currentData: null | InMemoryData = null;\nlet currentDependencies: null | Set<string> = null;\nlet currentOptimisticKey: null | number = null;\n\nconst makeNodeMap = <T>(): NodeMap<T> => ({\n  optimistic: makeDict(),\n  base: new Map(),\n  keys: [],\n});\n\n/** Before reading or writing the global state needs to be initialised */\nexport const initDataState = (\n  data: InMemoryData,\n  optimisticKey: number | null\n) => {\n  //@ts-ignore\n  window.currentData = currentData = data;\n  currentDependencies = new Set();\n  currentOptimisticKey = optimisticKey;\n  if (process.env.NODE_ENV !== 'production') {\n    currentDebugStack.length = 0;\n  }\n};\n\n/** Reset the data state after read/write is complete */\nexport const clearDataState = () => {\n  const data = currentData!;\n\n  if (!data.gcScheduled && data.gcBatch.size > 0) {\n    data.gcScheduled = true;\n    defer(() => {\n      gc(data);\n    });\n  }\n\n  if (data.storage && !data.persistenceScheduled) {\n    data.persistenceScheduled = true;\n    defer(() => {\n      data.storage!.write(data.persistenceBatch);\n      data.persistenceScheduled = false;\n      data.persistenceBatch = makeDict();\n    });\n  }\n\n  currentData = null;\n  currentDependencies = null;\n  currentOptimisticKey = null;\n  if (process.env.NODE_ENV !== 'production') {\n    currentDebugStack.length = 0;\n  }\n};\n\n/** As we're writing, we keep around all the records and links we've read or have written to */\nexport const getCurrentDependencies = (): Set<string> => {\n  invariant(\n    currentDependencies !== null,\n    'Invalid Cache call: The cache may only be accessed or mutated during' +\n      'operations like write or query, or as part of its resolvers, updaters, ' +\n      'or optimistic configs.',\n    2\n  );\n\n  return currentDependencies;\n};\n\nexport const make = (queryRootKey: string): InMemoryData => ({\n  persistenceScheduled: false,\n  persistenceBatch: makeDict(),\n  gcScheduled: false,\n  queryRootKey,\n  gcBatch: new Set(),\n  refCount: makeDict(),\n  refLock: makeDict(),\n  links: makeNodeMap(),\n  records: makeNodeMap(),\n  storage: null,\n});\n\n/** Adds a node value to a NodeMap (taking optimistic values into account */\nconst setNode = <T>(\n  map: NodeMap<T>,\n  entityKey: string,\n  fieldKey: string,\n  value: T\n) => {\n  // Optimistic values are written to a map in the optimistic dict\n  // All other values are written to the base map\n  let keymap: KeyMap<Dict<T | undefined>>;\n  if (currentOptimisticKey) {\n    // If the optimistic map doesn't exist yet, it' created, and\n    // the optimistic key is stored (in order of priority)\n    if (map.optimistic[currentOptimisticKey] === undefined) {\n      map.optimistic[currentOptimisticKey] = new Map();\n      map.keys.unshift(currentOptimisticKey);\n    }\n\n    keymap = map.optimistic[currentOptimisticKey];\n  } else {\n    keymap = map.base;\n  }\n\n  // On the map itself we get or create the entity as a dict\n  let entity = keymap.get(entityKey) as Dict<T | undefined>;\n  if (entity === undefined) {\n    keymap.set(entityKey, (entity = makeDict()));\n  }\n\n  // If we're setting undefined we delete the node's entry\n  // On optimistic layers we actually set undefined so it can\n  // override the base value\n  if (value === undefined && !currentOptimisticKey) {\n    delete entity[fieldKey];\n  } else {\n    entity[fieldKey] = value;\n  }\n};\n\n/** Gets a node value from a NodeMap (taking optimistic values into account */\nconst getNode = <T>(\n  map: NodeMap<T>,\n  entityKey: string,\n  fieldKey: string\n): T | undefined => {\n  // This first iterates over optimistic layers (in order)\n  for (let i = 0, l = map.keys.length; i < l; i++) {\n    const optimistic = map.optimistic[map.keys[i]];\n    const node = optimistic.get(entityKey);\n    // If the node and node value exists it is returned, including undefined\n    if (node !== undefined && fieldKey in node) {\n      return node[fieldKey];\n    }\n  }\n\n  // Otherwise we read the non-optimistic base value\n  const node = map.base.get(entityKey);\n  return node !== undefined ? node[fieldKey] : undefined;\n};\n\n/** Gets a node value from a NodeMap (taking optimistic values into account */\nconst getNodeParent = <T>(\n  map: NodeMap<T>,\n  entityKey: string,\n  fieldKey: string\n): Record<string, T | undefined> | undefined => {\n  // This first iterates over optimistic layers (in order)\n  for (let i = 0, l = map.keys.length; i < l; i++) {\n    const optimistic = map.optimistic[map.keys[i]];\n    const node = optimistic.get(entityKey);\n    // If the node and node value exists it is returned, including undefined\n    if (node !== undefined && fieldKey in node) {\n      return node;\n    }\n  }\n\n  // Otherwise we read the non-optimistic base value\n  const node = map.base.get(entityKey);\n  return node !== undefined ? node : undefined;\n};\n\n/** Clears an optimistic layers from a NodeMap */\nconst clearOptimisticNodes = <T>(map: NodeMap<T>, optimisticKey: number) => {\n  // Check whether the optimistic layer exists on the NodeMap\n  const index = map.keys.indexOf(optimisticKey);\n  if (index > -1) {\n    // Then delete it and splice out the optimisticKey\n    delete map.optimistic[optimisticKey];\n    map.keys.splice(index, 1);\n  }\n};\n\n/** Adjusts the reference count of an entity on a refCount dict by \"by\" and updates the gcBatch */\nconst updateRCForEntity = (\n  gcBatch: void | Set<string>,\n  refCount: Dict<number>,\n  entityKey: string,\n  by: number\n) => {\n  // Retrieve the reference count\n  const count = refCount[entityKey] !== undefined ? refCount[entityKey] : 0;\n  // Adjust it by the \"by\" value\n  const newCount = (refCount[entityKey] = (count + by) | 0);\n  // Add it to the garbage collection batch if it needs to be deleted or remove it\n  // from the batch if it needs to be kept\n  if (gcBatch !== undefined) {\n    if (newCount <= 0) gcBatch.add(entityKey);\n    else if (count <= 0 && newCount > 0) gcBatch.delete(entityKey);\n  }\n};\n\n/** Adjusts the reference counts of all entities of a link on a refCount dict by \"by\" and updates the gcBatch */\nconst updateRCForLink = (\n  gcBatch: void | Set<string>,\n  refCount: Dict<number>,\n  link: Link | undefined,\n  by: number\n) => {\n  if (typeof link === 'string') {\n    updateRCForEntity(gcBatch, refCount, link, by);\n  } else if (Array.isArray(link)) {\n    for (let i = 0, l = link.length; i < l; i++) {\n      const entityKey = link[i];\n      if (entityKey) {\n        updateRCForEntity(gcBatch, refCount, entityKey, by);\n      }\n    }\n  }\n};\n\n/** Writes all parsed FieldInfo objects of a given node dict to a given array if it hasn't been seen */\nconst extractNodeFields = <T>(\n  fieldInfos: FieldInfo[],\n  seenFieldKeys: Set<string>,\n  node: Dict<T> | undefined\n) => {\n  if (node !== undefined) {\n    for (const fieldKey in node) {\n      if (!seenFieldKeys.has(fieldKey)) {\n        // If the node hasn't been seen the serialized fieldKey is turnt back into\n        // a rich FieldInfo object that also contains the field's name and arguments\n        fieldInfos.push(fieldInfoOfKey(fieldKey));\n        seenFieldKeys.add(fieldKey);\n      }\n    }\n  }\n};\n\n/** Writes all parsed FieldInfo objects of all nodes in a NodeMap to a given array */\nconst extractNodeMapFields = <T>(\n  fieldInfos: FieldInfo[],\n  seenFieldKeys: Set<string>,\n  entityKey: string,\n  map: NodeMap<T>\n) => {\n  // Extracts FieldInfo for the entity in the base map\n  extractNodeFields(fieldInfos, seenFieldKeys, map.base.get(entityKey));\n\n  // Then extracts FieldInfo for the entity from the optimistic maps\n  for (let i = 0, l = map.keys.length; i < l; i++) {\n    const optimistic = map.optimistic[map.keys[i]];\n    extractNodeFields(fieldInfos, seenFieldKeys, optimistic.get(entityKey));\n  }\n};\n\n/** Garbage collects all entities that have been marked as having no references */\nexport const gc = (data: InMemoryData) => {\n  // Reset gcScheduled flag\n  data.gcScheduled = false;\n  // Iterate over all entities that have been marked for deletion\n  // Entities have been marked for deletion in `updateRCForEntity` if\n  // their reference count dropped to 0\n  data.gcBatch.forEach(entityKey => {\n    // Check first whether the reference count is still 0\n    const rc = data.refCount[entityKey] || 0;\n    if (rc <= 0) {\n      // Each optimistic layer may also still contain some references to marked entities\n      for (const optimisticKey in data.refLock) {\n        const refCount = data.refLock[optimisticKey];\n        const locks = refCount[entityKey] || 0;\n        // If the optimistic layer has any references to the entity, don't GC it,\n        // otherwise delete the reference count from the optimistic layer\n        if (locks > 0) return;\n        delete refCount[entityKey];\n      }\n\n      // All conditions are met: The entity can be deleted\n\n      // Delete the reference count, and delete the entity from the GC batch\n      delete data.refCount[entityKey];\n      data.gcBatch.delete(entityKey);\n\n      // Delete the record and for each of its fields, delete them on the persistence\n      // layer if one is present\n      // No optimistic data needs to be deleted, as the entity is not being referenced by\n      // anything and optimistic layers will eventually be deleted anyway\n      const recordsNode = data.records.base.get(entityKey);\n      if (recordsNode !== undefined) {\n        data.records.base.delete(entityKey);\n        if (data.storage) {\n          for (const fieldKey in recordsNode) {\n            const key = prefixKey('r', joinKeys(entityKey, fieldKey));\n            data.persistenceBatch[key] = undefined;\n          }\n        }\n      }\n\n      // Delete all the entity's links, but also update the reference count\n      // for those links (which can lead to an unrolled recursive GC of the children)\n      const linkNode = data.links.base.get(entityKey);\n      if (linkNode !== undefined) {\n        data.links.base.delete(entityKey);\n        for (const fieldKey in linkNode) {\n          // Delete all links from the persistence layer if one is present\n          if (data.storage) {\n            const key = prefixKey('l', joinKeys(entityKey, fieldKey));\n            data.persistenceBatch[key] = undefined;\n          }\n\n          updateRCForLink(data.gcBatch, data.refCount, linkNode[fieldKey], -1);\n        }\n      }\n    } else {\n      data.gcBatch.delete(entityKey);\n    }\n  });\n};\n\nconst updateDependencies = (entityKey: string, fieldKey?: string) => {\n  if (fieldKey !== '__typename') {\n    if (entityKey !== currentData!.queryRootKey) {\n      currentDependencies!.add(entityKey);\n    } else if (fieldKey !== undefined) {\n      currentDependencies!.add(joinKeys(entityKey, fieldKey));\n    }\n  }\n};\n\n/** Reads an entity's field (a \"record\") from data */\nexport const readRecord = (\n  entityKey: string,\n  fieldKey: string\n): EntityField => {\n  updateDependencies(entityKey, fieldKey);\n  return getNode(currentData!.records, entityKey, fieldKey);\n};\n\nexport const readParent = (\n  entityKey: string,\n  fieldKey: string\n): EntityField => {\n  updateDependencies(entityKey, fieldKey);\n  return getNodeParent(currentData!.records, entityKey, fieldKey);\n};\n\n/** Reads an entity's link from data */\nexport const readLink = (\n  entityKey: string,\n  fieldKey: string\n): Link | undefined => {\n  updateDependencies(entityKey, fieldKey);\n  return getNode(currentData!.links, entityKey, fieldKey);\n};\n\n/** Writes an entity's field (a \"record\") to data */\nexport const writeRecord = action((\n  entityKey: string,\n  fieldKey: string,\n  value: EntityField\n) => {\n  updateDependencies(entityKey, fieldKey);\n  setNode(currentData!.records, entityKey, fieldKey, value);\n  if (currentData!.storage && !currentOptimisticKey) {\n    const key = prefixKey('r', joinKeys(entityKey, fieldKey));\n    currentData!.persistenceBatch[key] = value;\n  }\n});\n\nexport const hasField = (entityKey: string, fieldKey: string): boolean =>\n  readRecord(entityKey, fieldKey) !== undefined ||\n  readLink(entityKey, fieldKey) !== undefined;\n\n/** Writes an entity's link to data */\nexport const writeLink = (\n  entityKey: string,\n  fieldKey: string,\n  link: Link | undefined\n) => {\n  const data = currentData!;\n  // Retrieve the reference counting dict or the optimistic reference locking dict\n  let refCount: Dict<number>;\n  // Retrive the link NodeMap from either an optimistic or the base layer\n  let links: KeyMap<Dict<Link | undefined>> | undefined;\n  // Set the GC batch if we're not optimistically updating\n  let gcBatch: void | Set<string>;\n  if (currentOptimisticKey) {\n    // The refLock counters are also reference counters, but they prevent\n    // garbage collection instead of being used to trigger it\n    refCount =\n      data.refLock[currentOptimisticKey] ||\n      (data.refLock[currentOptimisticKey] = makeDict());\n    links = data.links.optimistic[currentOptimisticKey];\n  } else {\n    if (data.storage) {\n      const key = prefixKey('l', joinKeys(entityKey, fieldKey));\n      data.persistenceBatch[key] = link;\n    }\n    refCount = data.refCount;\n    links = data.links.base;\n    gcBatch = data.gcBatch;\n  }\n\n  // Retrieve the previous link for this field\n  const prevLinkNode = links !== undefined ? links.get(entityKey) : undefined;\n  const prevLink = prevLinkNode !== undefined ? prevLinkNode[fieldKey] : null;\n\n  // Update dependencies\n  updateDependencies(entityKey, fieldKey);\n  // Update the link\n  setNode(data.links, entityKey, fieldKey, link);\n  // First decrease the reference count for the previous link\n  updateRCForLink(gcBatch, refCount, prevLink, -1);\n  // Then increase the reference count for the new link\n  updateRCForLink(gcBatch, refCount, link, 1);\n};\n\n/** Removes an optimistic layer of links and records */\nexport const clearOptimistic = (data: InMemoryData, optimisticKey: number) => {\n  // We also delete the optimistic reference locks\n  delete data.refLock[optimisticKey];\n  clearOptimisticNodes(data.records, optimisticKey);\n  clearOptimisticNodes(data.links, optimisticKey);\n};\n\n/** Return an array of FieldInfo (info on all the fields and their arguments) for a given entity */\nexport const inspectFields = (entityKey: string): FieldInfo[] => {\n  const { links, records } = currentData!;\n  const fieldInfos: FieldInfo[] = [];\n  const seenFieldKeys: Set<string> = new Set();\n  // Update dependencies\n  updateDependencies(entityKey);\n  // Extract FieldInfos to the fieldInfos array for links and records\n  // This also deduplicates by keeping track of fieldKeys in the seenFieldKeys Set\n  extractNodeMapFields(fieldInfos, seenFieldKeys, entityKey, links);\n  extractNodeMapFields(fieldInfos, seenFieldKeys, entityKey, records);\n  return fieldInfos;\n};\n\nexport const hydrateData = (\n  data: InMemoryData,\n  storage: StorageAdapter,\n  entries: SerializedEntries\n) => {\n  initDataState(data, 0);\n  for (const key in entries) {\n    const dotIndex = key.indexOf('.');\n    const entityKey = key.slice(2, dotIndex);\n    const fieldKey = key.slice(dotIndex + 1);\n    switch (key.charCodeAt(0)) {\n      case 108:\n        writeLink(entityKey, fieldKey, entries[key] as Link);\n        break;\n      case 114:\n        writeRecord(entityKey, fieldKey, entries[key]);\n        break;\n    }\n  }\n  clearDataState();\n  data.storage = storage;\n};\n","import { FieldNode, InlineFragmentNode, FragmentDefinitionNode } from 'graphql';\n\nimport { warn, pushDebugNode } from '../helpers/help';\nimport { hasField } from '../store/data';\nimport { Store, keyOfField } from '../store';\n\nimport {\n  Fragments,\n  Variables,\n  SelectionSet,\n  DataField,\n  NullArray,\n  Data,\n} from '../types';\n\nimport {\n  SchemaPredicates,\n  getTypeCondition,\n  getFieldArguments,\n  shouldInclude,\n  isFieldNode,\n  isInlineFragment,\n  getSelectionSet,\n  getName,\n} from '../ast';\n\ninterface Context {\n  store: Store;\n  variables: Variables;\n  fragments: Fragments;\n  schemaPredicates?: SchemaPredicates;\n}\n\nconst isFragmentHeuristicallyMatching = (\n  node: InlineFragmentNode | FragmentDefinitionNode,\n  typename: void | string,\n  entityKey: string,\n  ctx: Context\n) => {\n  if (!typename) return false;\n  const typeCondition = getTypeCondition(node);\n  if (typename === typeCondition) return true;\n\n  warn(\n    'Heuristic Fragment Matching: A fragment is trying to match against the `' +\n      typename +\n      '` type, ' +\n      'but the type condition is `' +\n      typeCondition +\n      '`. Since GraphQL allows for interfaces `' +\n      typeCondition +\n      '` may be an' +\n      'interface.\\nA schema needs to be defined for this match to be deterministic, ' +\n      'otherwise the fragment will be matched heuristically!',\n    16\n  );\n\n  return !getSelectionSet(node).some(node => {\n    if (!isFieldNode(node)) return false;\n    const fieldKey = keyOfField(\n      getName(node),\n      getFieldArguments(node, ctx.variables)\n    );\n    return !hasField(entityKey, fieldKey);\n  });\n};\n\nexport class SelectionIterator {\n  typename: void | string;\n  entityKey: string;\n  indexStack: number[];\n  context: Context;\n  selectionStack: SelectionSet[];\n\n  constructor(\n    typename: void | string,\n    entityKey: string,\n    select: SelectionSet,\n    ctx: Context\n  ) {\n    this.typename = typename;\n    this.entityKey = entityKey;\n    this.context = ctx;\n    this.indexStack = [0];\n    this.selectionStack = [select];\n  }\n\n  next(): void | FieldNode {\n    while (this.indexStack.length !== 0) {\n      const index = this.indexStack[this.indexStack.length - 1]++;\n      const select = this.selectionStack[this.selectionStack.length - 1];\n      if (index >= select.length) {\n        this.indexStack.pop();\n        this.selectionStack.pop();\n        continue;\n      } else {\n        const node = select[index];\n        if (!shouldInclude(node, this.context.variables)) {\n          continue;\n        } else if (!isFieldNode(node)) {\n          // A fragment is either referred to by FragmentSpread or inline\n          const fragmentNode = !isInlineFragment(node)\n            ? this.context.fragments[getName(node)]\n            : node;\n\n          if (fragmentNode !== undefined) {\n            if (process.env.NODE_ENV !== 'production') {\n              pushDebugNode(this.typename, fragmentNode);\n            }\n\n            const isMatching =\n              this.context.schemaPredicates !== undefined\n                ? this.context.schemaPredicates.isInterfaceOfType(\n                    getTypeCondition(fragmentNode),\n                    this.typename\n                  )\n                : isFragmentHeuristicallyMatching(\n                    fragmentNode,\n                    this.typename,\n                    this.entityKey,\n                    this.context\n                  );\n\n            if (isMatching) {\n              this.indexStack.push(0);\n              this.selectionStack.push(getSelectionSet(fragmentNode));\n            }\n          }\n\n          continue;\n        } else if (getName(node) === '__typename') {\n          continue;\n        } else {\n          return node;\n        }\n      }\n    }\n\n    return undefined;\n  }\n}\n\nexport const ensureData = (x: DataField): Data | NullArray<Data> | null =>\n  x === undefined ? null : (x as Data | NullArray<Data>);\n","import { FieldNode, DocumentNode, FragmentDefinitionNode } from 'graphql';\n\nimport {\n  getFieldAlias,\n  getFragments,\n  getMainOperation,\n  getSelectionSet,\n  normalizeVariables,\n  getFragmentTypeName,\n  getName,\n  getFieldArguments,\n  SchemaPredicates,\n} from '../ast';\n\nimport {\n  NullArray,\n  Fragments,\n  Variables,\n  Data,\n  Link,\n  SelectionSet,\n  OperationRequest,\n} from '../types';\n\nimport {\n  Store,\n  getCurrentDependencies,\n  initDataState,\n  clearDataState,\n  makeDict,\n  joinKeys,\n  keyOfField,\n} from '../store';\n\nimport * as InMemoryData from '../store/data';\nimport { invariant, warn, pushDebugNode } from '../helpers/help';\nimport { SelectionIterator, ensureData } from './shared';\nimport { action } from 'mobx';\n\nexport interface WriteResult {\n  dependencies: Set<string>;\n}\n\ninterface Context {\n  parentTypeName: string;\n  parentKey: string;\n  parentFieldKey: string;\n  fieldName: string;\n  result: WriteResult;\n  store: Store;\n  variables: Variables;\n  fragments: Fragments;\n  optimistic?: boolean;\n  schemaPredicates?: SchemaPredicates;\n}\n\n/** Writes a request given its response to the store */\nexport const write = action((\n  store: Store,\n  request: OperationRequest,\n  data: Data\n): WriteResult => {\n  initDataState(store.data, 0);\n  const result = startWrite(store, request, data);\n  clearDataState();\n  return result;\n});\n\nexport const startWrite = (\n  store: Store,\n  request: OperationRequest,\n  data: Data\n) => {\n  const operation = getMainOperation(request.query);\n  const result: WriteResult = { dependencies: getCurrentDependencies() };\n\n  const select = getSelectionSet(operation);\n  const operationName = store.getRootKey(operation.operation);\n\n  const ctx: Context = {\n    parentTypeName: operationName,\n    parentKey: operationName,\n    parentFieldKey: '',\n    fieldName: '',\n    variables: normalizeVariables(operation, request.variables),\n    fragments: getFragments(request.query),\n    result,\n    store,\n    schemaPredicates: store.schemaPredicates,\n  };\n\n  if (process.env.NODE_ENV !== 'production') {\n    pushDebugNode(operationName, operation);\n  }\n\n  if (operationName === ctx.store.getRootKey('query')) {\n    writeSelection(ctx, operationName, select, data);\n  } else {\n    writeRoot(ctx, operationName, select, data);\n  }\n\n  return result;\n};\n\nexport const writeOptimistic = (\n  store: Store,\n  request: OperationRequest,\n  optimisticKey: number\n): WriteResult => {\n  initDataState(store.data, optimisticKey);\n\n  const operation = getMainOperation(request.query);\n  const result: WriteResult = { dependencies: getCurrentDependencies() };\n\n  const mutationRootKey = store.getRootKey('mutation');\n  const operationName = store.getRootKey(operation.operation);\n  invariant(\n    operationName === mutationRootKey,\n    'writeOptimistic(...) was called with an operation that is not a mutation.\\n' +\n      'This case is unsupported and should never occur.',\n    10\n  );\n\n  if (process.env.NODE_ENV !== 'production') {\n    pushDebugNode(operationName, operation);\n  }\n\n  const ctx: Context = {\n    parentTypeName: mutationRootKey,\n    parentKey: mutationRootKey,\n    parentFieldKey: '',\n    fieldName: '',\n    variables: normalizeVariables(operation, request.variables),\n    fragments: getFragments(request.query),\n    result,\n    store,\n    schemaPredicates: store.schemaPredicates,\n    optimistic: true,\n  };\n\n  const data = makeDict();\n  const iter = new SelectionIterator(\n    operationName,\n    operationName,\n    getSelectionSet(operation),\n    ctx\n  );\n\n  let node: FieldNode | void;\n  while ((node = iter.next()) !== undefined) {\n    if (node.selectionSet !== undefined) {\n      const fieldName = getName(node);\n      const resolver = ctx.store.optimisticMutations[fieldName];\n\n      if (resolver !== undefined) {\n        // We have to update the context to reflect up-to-date ResolveInfo\n        ctx.fieldName = fieldName;\n\n        const fieldArgs = getFieldArguments(node, ctx.variables);\n        const resolverValue = resolver(fieldArgs || makeDict(), ctx.store, ctx);\n        const resolverData = ensureData(resolverValue);\n        writeRootField(ctx, resolverData, getSelectionSet(node));\n        data[fieldName] = resolverValue;\n        const updater = ctx.store.updates[mutationRootKey][fieldName];\n        if (updater !== undefined) {\n          updater(data, fieldArgs || makeDict(), ctx.store, ctx);\n        }\n      }\n    }\n  }\n\n  clearDataState();\n  return result;\n};\n\nexport const writeFragment = (\n  store: Store,\n  query: DocumentNode,\n  data: Data,\n  variables?: Variables\n) => {\n  const fragments = getFragments(query);\n  const names = Object.keys(fragments);\n  const fragment = fragments[names[0]] as FragmentDefinitionNode;\n  if (fragment === undefined) {\n    return warn(\n      'writeFragment(...) was called with an empty fragment.\\n' +\n        'You have to call it with at least one fragment in your GraphQL document.',\n      11\n    );\n  }\n\n  const typename = getFragmentTypeName(fragment);\n  const writeData = { __typename: typename, ...data } as Data;\n  const entityKey = store.keyOfEntity(writeData);\n  if (!entityKey) {\n    return warn(\n      \"Can't generate a key for writeFragment(...) data.\\n\" +\n        'You have to pass an `id` or `_id` field or create a custom `keys` config for `' +\n        typename +\n        '`.',\n      12\n    );\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    pushDebugNode(typename, fragment);\n  }\n\n  const ctx: Context = {\n    parentTypeName: typename,\n    parentKey: entityKey,\n    parentFieldKey: '',\n    fieldName: '',\n    variables: variables || {},\n    fragments,\n    result: { dependencies: getCurrentDependencies() },\n    store,\n    schemaPredicates: store.schemaPredicates,\n  };\n\n  writeSelection(ctx, entityKey, getSelectionSet(fragment), writeData);\n};\n\nconst writeSelection = (\n  ctx: Context,\n  entityKey: string,\n  select: SelectionSet,\n  data: Data\n) => {\n  const isQuery = entityKey === ctx.store.getRootKey('query');\n  const typename = isQuery ? entityKey : data.__typename;\n  if (typeof typename !== 'string') return;\n\n  InMemoryData.writeRecord(entityKey, '__typename', typename);\n\n  const iter = new SelectionIterator(typename, entityKey, select, ctx);\n\n  let node: FieldNode | void;\n  while ((node = iter.next()) !== undefined) {\n    const fieldName = getName(node);\n    const fieldArgs = getFieldArguments(node, ctx.variables);\n    const fieldKey = keyOfField(fieldName, fieldArgs);\n    const fieldValue = data[getFieldAlias(node)];\n    const key = joinKeys(entityKey, fieldKey);\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (fieldValue === undefined) {\n        const advice = ctx.optimistic\n          ? '\\nYour optimistic result may be missing a field!'\n          : '';\n\n        const expected =\n          node.selectionSet === undefined\n            ? 'scalar (number, boolean, etc)'\n            : 'selection set';\n\n        warn(\n          'Invalid undefined: The field at `' +\n            fieldKey +\n            '` is `undefined`, but the GraphQL query expects a ' +\n            expected +\n            ' for this field.' +\n            advice,\n          13\n        );\n\n        continue; // Skip this field\n      } else if (ctx.schemaPredicates && typename) {\n        ctx.schemaPredicates.isFieldAvailableOnType(typename, fieldName);\n      }\n    }\n\n    if (node.selectionSet === undefined) {\n      // This is a leaf node, so we're setting the field's value directly\n      InMemoryData.writeRecord(entityKey, fieldKey, fieldValue);\n    } else {\n      // Process the field and write links for the child entities that have been written\n      const fieldData = ensureData(fieldValue);\n      const link = writeField(ctx, key, getSelectionSet(node), fieldData);\n      InMemoryData.writeLink(entityKey, fieldKey, link);\n    }\n  }\n};\n\nconst writeField = (\n  ctx: Context,\n  parentFieldKey: string,\n  select: SelectionSet,\n  data: null | Data | NullArray<Data>\n): Link => {\n  if (Array.isArray(data)) {\n    const newData = new Array(data.length);\n    for (let i = 0, l = data.length; i < l; i++) {\n      const item = data[i];\n      // Append the current index to the parentFieldKey fallback\n      const indexKey = joinKeys(parentFieldKey, `${i}`);\n      // Recursively write array data\n      const links = writeField(ctx, indexKey, select, item);\n      // Link cannot be expressed as a recursive type\n      newData[i] = links as string | null;\n    }\n\n    return newData;\n  } else if (data === null) {\n    return null;\n  }\n\n  const entityKey = ctx.store.keyOfEntity(data);\n  const key = entityKey !== null ? entityKey : parentFieldKey;\n  const typename = data.__typename;\n\n  if (\n    ctx.store.keys[data.__typename] === undefined &&\n    entityKey === null &&\n    typeof typename === 'string' &&\n    !typename.endsWith('Connection') &&\n    !typename.endsWith('Edge') &&\n    typename !== 'PageInfo'\n  ) {\n    warn(\n      'Invalid key: The GraphQL query at the field at `' +\n        parentFieldKey +\n        '` has a selection set, ' +\n        'but no key could be generated for the data at this field.\\n' +\n        'You have to request `id` or `_id` fields for all selection sets or create ' +\n        'a custom `keys` config for `' +\n        typename +\n        '`.\\n' +\n        'Entities without keys will be embedded directly on the parent entity. ' +\n        'If this is intentional, create a `keys` config for `' +\n        typename +\n        '` that always returns null.',\n      15\n    );\n  }\n\n  writeSelection(ctx, key, select, data);\n  return key;\n};\n\n// This is like writeSelection but assumes no parent entity exists\nconst writeRoot = (\n  ctx: Context,\n  typename: string,\n  select: SelectionSet,\n  data: Data\n) => {\n  const isRootField =\n    typename === ctx.store.getRootKey('mutation') ||\n    typename === ctx.store.getRootKey('subscription');\n\n  const iter = new SelectionIterator(typename, typename, select, ctx);\n\n  let node: FieldNode | void;\n  while ((node = iter.next()) !== undefined) {\n    const fieldName = getName(node);\n    const fieldArgs = getFieldArguments(node, ctx.variables);\n    const fieldKey = joinKeys(typename, keyOfField(fieldName, fieldArgs));\n    if (node.selectionSet !== undefined) {\n      const fieldValue = ensureData(data[getFieldAlias(node)]);\n      writeRootField(ctx, fieldValue, getSelectionSet(node));\n    }\n\n    if (isRootField) {\n      // We have to update the context to reflect up-to-date ResolveInfo\n      ctx.parentTypeName = typename;\n      ctx.parentKey = typename;\n      ctx.parentFieldKey = fieldKey;\n      ctx.fieldName = fieldName;\n\n      // We run side-effect updates after the default, normalized updates\n      // so that the data is already available in-store if necessary\n      const updater = ctx.store.updates[typename][fieldName];\n      if (updater !== undefined) {\n        updater(data, fieldArgs || makeDict(), ctx.store, ctx);\n      }\n    }\n  }\n};\n\n// This is like writeField but doesn't fall back to a generated key\nconst writeRootField = (\n  ctx: Context,\n  data: null | Data | NullArray<Data>,\n  select: SelectionSet\n) => {\n  if (Array.isArray(data)) {\n    const newData = new Array(data.length);\n    for (let i = 0, l = data.length; i < l; i++)\n      newData[i] = writeRootField(ctx, data[i], select);\n    return newData;\n  } else if (data === null) {\n    return;\n  }\n\n  // Write entity to key that falls back to the given parentFieldKey\n  const entityKey = ctx.store.keyOfEntity(data);\n  if (entityKey !== null) {\n    writeSelection(ctx, entityKey, select, data);\n  } else {\n    const typename = data.__typename;\n    writeRoot(ctx, typename, select, data);\n  }\n};\n","import { FieldNode } from 'graphql';\n\nimport {\n  getMainOperation,\n  normalizeVariables,\n  getFragments,\n  getSelectionSet,\n  getName,\n  getFieldArguments,\n} from '../ast';\n\nimport {\n  EntityField,\n  OperationRequest,\n  Variables,\n  Fragments,\n  SelectionSet,\n} from '../types';\n\nimport * as InMemoryData from '../store/data';\nimport { Store, keyOfField } from '../store';\nimport { SchemaPredicates } from '../ast';\nimport { SelectionIterator } from './shared';\n\ninterface Context {\n  store: Store;\n  variables: Variables;\n  fragments: Fragments;\n  schemaPredicates?: SchemaPredicates;\n}\n\nexport const invalidate = (store: Store, request: OperationRequest) => {\n  const operation = getMainOperation(request.query);\n\n  const ctx: Context = {\n    variables: normalizeVariables(operation, request.variables),\n    fragments: getFragments(request.query),\n    store,\n    schemaPredicates: store.schemaPredicates,\n  };\n\n  invalidateSelection(\n    ctx,\n    ctx.store.getRootKey('query'),\n    getSelectionSet(operation)\n  );\n};\n\nexport const invalidateSelection = (\n  ctx: Context,\n  entityKey: string,\n  select: SelectionSet\n) => {\n  const isQuery = entityKey === 'Query';\n\n  let typename: EntityField;\n  if (!isQuery) {\n    typename = InMemoryData.readRecord(entityKey, '__typename');\n    if (typeof typename !== 'string') {\n      return;\n    } else {\n      InMemoryData.writeRecord(entityKey, '__typename', undefined);\n    }\n  } else {\n    typename = entityKey;\n  }\n\n  const iter = new SelectionIterator(typename, entityKey, select, ctx);\n\n  let node: FieldNode | void;\n  while ((node = iter.next()) !== undefined) {\n    const fieldName = getName(node);\n    const fieldKey = keyOfField(\n      fieldName,\n      getFieldArguments(node, ctx.variables)\n    );\n\n    if (\n      process.env.NODE_ENV !== 'production' &&\n      ctx.schemaPredicates &&\n      typename\n    ) {\n      ctx.schemaPredicates.isFieldAvailableOnType(typename, fieldName);\n    }\n\n    if (node.selectionSet === undefined) {\n      InMemoryData.writeRecord(entityKey, fieldKey, undefined);\n    } else {\n      const fieldSelect = getSelectionSet(node);\n      const link = InMemoryData.readLink(entityKey, fieldKey);\n\n      InMemoryData.writeLink(entityKey, fieldKey, undefined);\n      InMemoryData.writeRecord(entityKey, fieldKey, undefined);\n\n      if (Array.isArray(link)) {\n        for (let i = 0, l = link.length; i < l; i++) {\n          const childLink = link[i];\n          if (childLink !== null) {\n            invalidateSelection(ctx, childLink, fieldSelect);\n          }\n        }\n      } else if (link) {\n        invalidateSelection(ctx, link, fieldSelect);\n      }\n    }\n  }\n};\n","import { DocumentNode } from 'graphql';\nimport { createRequest } from 'urql/core';\n\nimport {\n  Cache,\n  FieldInfo,\n  ResolverConfig,\n  DataField,\n  Variables,\n  Data,\n  QueryInput,\n  UpdatesConfig,\n  OptimisticMutationConfig,\n  KeyingConfig,\n} from '../types';\n\nimport { read, readFragment } from '../operations/query';\nimport { writeFragment, startWrite } from '../operations/write';\nimport { invalidate } from '../operations/invalidate';\nimport { SchemaPredicates } from '../ast';\nimport { keyOfField } from './keys';\nimport * as InMemoryData from './data';\n\ntype RootField = 'query' | 'mutation' | 'subscription';\n\nexport class Store implements Cache {\n  data: InMemoryData.InMemoryData;\n\n  resolvers: ResolverConfig;\n  updates: UpdatesConfig;\n  optimisticMutations: OptimisticMutationConfig;\n  keys: KeyingConfig;\n  schemaPredicates?: SchemaPredicates;\n\n  rootFields: { query: string; mutation: string; subscription: string };\n  rootNames: { [name: string]: RootField };\n\n  constructor(\n    schemaPredicates?: SchemaPredicates,\n    resolvers?: ResolverConfig,\n    updates?: Partial<UpdatesConfig>,\n    optimisticMutations?: OptimisticMutationConfig,\n    keys?: KeyingConfig\n  ) {\n    this.resolvers = resolvers || {};\n    this.optimisticMutations = optimisticMutations || {};\n    this.keys = keys || {};\n    this.schemaPredicates = schemaPredicates;\n\n    this.updates = {\n      Mutation: (updates && updates.Mutation) || {},\n      Subscription: (updates && updates.Subscription) || {},\n    } as UpdatesConfig;\n\n    if (schemaPredicates) {\n      const { schema } = schemaPredicates;\n      const queryType = schema.getQueryType();\n      const mutationType = schema.getMutationType();\n      const subscriptionType = schema.getSubscriptionType();\n\n      const queryName = queryType ? queryType.name : 'Query';\n      const mutationName = mutationType ? mutationType.name : 'Mutation';\n      const subscriptionName = subscriptionType\n        ? subscriptionType.name\n        : 'Subscription';\n\n      this.rootFields = {\n        query: queryName,\n        mutation: mutationName,\n        subscription: subscriptionName,\n      };\n\n      this.rootNames = {\n        [queryName]: 'query',\n        [mutationName]: 'mutation',\n        [subscriptionName]: 'subscription',\n      };\n    } else {\n      this.rootFields = {\n        query: 'Query',\n        mutation: 'Mutation',\n        subscription: 'Subscription',\n      };\n\n      this.rootNames = {\n        Query: 'query',\n        Mutation: 'mutation',\n        Subscription: 'subscription',\n      };\n    }\n\n    this.data = InMemoryData.make(this.getRootKey('query'));\n  }\n\n  gcScheduled = false;\n  gc = () => {\n    InMemoryData.gc(this.data);\n    this.gcScheduled = false;\n  };\n\n  keyOfField = keyOfField;\n\n  getRootKey(name: RootField) {\n    return this.rootFields[name];\n  }\n\n  keyOfEntity(data: Data) {\n    const { __typename: typename, id, _id } = data;\n    if (!typename) {\n      return null;\n    } else if (this.rootNames[typename] !== undefined) {\n      return typename;\n    }\n\n    let key: string | null | void;\n    if (this.keys[typename]) {\n      key = this.keys[typename](data);\n    } else if (id !== undefined && id !== null) {\n      key = `${id}`;\n    } else if (_id !== undefined && _id !== null) {\n      key = `${_id}`;\n    }\n\n    return key ? `${typename}:${key}` : null;\n  }\n\n  resolveFieldByKey(entity: Data | string | null, fieldKey: string): DataField {\n    const entityKey =\n      entity !== null && typeof entity !== 'string'\n        ? this.keyOfEntity(entity)\n        : entity;\n    if (entityKey === null) return null;\n    const fieldValue = InMemoryData.readRecord(entityKey, fieldKey);\n    if (fieldValue !== undefined) return fieldValue;\n    const link = InMemoryData.readLink(entityKey, fieldKey);\n    return link ? link : null;\n  }\n\n  resolve(\n    entity: Data | string | null,\n    field: string,\n    args?: Variables\n  ): DataField {\n    return this.resolveFieldByKey(entity, keyOfField(field, args));\n  }\n\n  invalidateQuery(query: string | DocumentNode, variables?: Variables) {\n    invalidate(this, createRequest(query, variables));\n  }\n\n  inspectFields(entity: Data | string | null): FieldInfo[] {\n    const entityKey =\n      entity !== null && typeof entity !== 'string'\n        ? this.keyOfEntity(entity)\n        : entity;\n    return entityKey !== null ? InMemoryData.inspectFields(entityKey) : [];\n  }\n\n  updateQuery(\n    input: QueryInput,\n    updater: (data: Data | null) => Data | null\n  ): void {\n    const request = createRequest(input.query, input.variables);\n    const output = updater(this.readQuery(request as QueryInput));\n    if (output !== null) {\n      startWrite(this, request, output);\n    }\n  }\n\n  readQuery(input: QueryInput): Data | null {\n    return read(this, createRequest(input.query, input.variables)).data;\n  }\n\n  readFragment(\n    dataFragment: DocumentNode,\n    entity: string | Data,\n    variables?: Variables\n  ): Data | null {\n    return readFragment(this, dataFragment, entity, variables);\n  }\n\n  writeFragment(\n    dataFragment: DocumentNode,\n    data: Data,\n    variables?: Variables\n  ): void {\n    writeFragment(this, dataFragment, data, variables);\n  }\n}\n","import {\n  FieldNode,\n  OperationDefinitionNode,\n  valueFromASTUntyped,\n} from 'graphql';\n\nimport { getName } from './node';\nimport { makeDict } from '../store';\nimport { Variables } from '../types';\n\n/** Evaluates a fields arguments taking vars into account */\nexport const getFieldArguments = (\n  node: FieldNode,\n  vars: Variables\n): null | Variables => {\n  if (node.arguments === undefined || node.arguments.length === 0) {\n    return null;\n  }\n\n  const args = makeDict();\n  let argsSize = 0;\n\n  for (let i = 0, l = node.arguments.length; i < l; i++) {\n    const arg = node.arguments[i];\n    const value = valueFromASTUntyped(arg.value, vars);\n    if (value !== undefined && value !== null) {\n      args[getName(arg)] = value;\n      argsSize++;\n    }\n  }\n\n  return argsSize > 0 ? args : null;\n};\n\n/** Returns a normalized form of variables with defaulted values */\nexport const normalizeVariables = (\n  node: OperationDefinitionNode,\n  input: void | object\n): Variables => {\n  if (node.variableDefinitions === undefined) {\n    return {};\n  }\n\n  const args: Variables = (input as Variables) || {};\n\n  return node.variableDefinitions.reduce((vars, def) => {\n    const name = getName(def.variable);\n    let value = args[name];\n    if (value === undefined) {\n      if (def.defaultValue !== undefined) {\n        value = valueFromASTUntyped(def.defaultValue, args);\n      } else {\n        return vars;\n      }\n    }\n\n    vars[name] = value;\n    return vars;\n  }, makeDict());\n};\n","import {\n  buildClientSchema,\n  isNullableType,\n  isListType,\n  isNonNullType,\n  GraphQLSchema,\n  GraphQLAbstractType,\n  GraphQLObjectType,\n  GraphQLInterfaceType,\n  GraphQLUnionType,\n} from 'graphql';\n\nimport { invariant, warn } from '../helpers/help';\n\nexport class SchemaPredicates {\n  schema: GraphQLSchema;\n\n  constructor(schema: object) {\n    this.schema = buildClientSchema(schema as any);\n  }\n\n  isFieldNullable(typename: string, fieldName: string): boolean {\n    const field = getField(this.schema, typename, fieldName);\n    if (field === undefined) return false;\n    return isNullableType(field.type);\n  }\n\n  isListNullable(typename: string, fieldName: string): boolean {\n    const field = getField(this.schema, typename, fieldName);\n    if (field === undefined) return false;\n    const ofType = isNonNullType(field.type) ? field.type.ofType : field.type;\n    return isListType(ofType) && isNullableType(ofType.ofType);\n  }\n\n  isFieldAvailableOnType(typename: string, fieldname: string): boolean {\n    return !!getField(this.schema, typename, fieldname);\n  }\n\n  isInterfaceOfType(\n    typeCondition: null | string,\n    typename: string | void\n  ): boolean {\n    if (!typename || !typeCondition) return false;\n    if (typename === typeCondition) return true;\n\n    const abstractType = this.schema.getType(typeCondition);\n    const objectType = this.schema.getType(typename);\n\n    if (abstractType instanceof GraphQLObjectType) {\n      return abstractType === objectType;\n    }\n\n    expectAbstractType(abstractType, typeCondition);\n    expectObjectType(objectType, typename);\n    return this.schema.isPossibleType(abstractType, objectType);\n  }\n}\n\nconst getField = (\n  schema: GraphQLSchema,\n  typename: string,\n  fieldName: string\n) => {\n  const object = schema.getType(typename);\n  expectObjectType(object, typename);\n\n  const field = object.getFields()[fieldName];\n  if (field === undefined) {\n    warn(\n      'Invalid field: The field `' +\n        fieldName +\n        '` does not exist on `' +\n        typename +\n        '`, ' +\n        'but the GraphQL document expects it to exist.\\n' +\n        'Traversal will continue, however this may lead to undefined behavior!',\n      4\n    );\n\n    return undefined;\n  }\n\n  return field;\n};\n\nfunction expectObjectType(x: any, typename: string): asserts x is GraphQLObjectType {\n  invariant(\n    x instanceof GraphQLObjectType,\n    'Invalid Object type: The type `' +\n      typename +\n      '` is not an object in the defined schema, ' +\n      'but the GraphQL document is traversing it.',\n    3\n  );\n}\n\nfunction expectAbstractType(x: any, typename: string): asserts x is GraphQLAbstractType {\n  invariant(\n    x instanceof GraphQLInterfaceType || x instanceof GraphQLUnionType,\n    'Invalid Abstract type: The type `' +\n      typename +\n      '` is not an Interface or Union type in the defined schema, ' +\n      'but a fragment in the GraphQL document is using it as a type condition.',\n    5\n  );\n}\n","import {\n  SelectionNode,\n  DefinitionNode,\n  DocumentNode,\n  FragmentDefinitionNode,\n  OperationDefinitionNode,\n  valueFromASTUntyped,\n  Kind,\n} from 'graphql';\n\nimport { invariant } from '../helpers/help';\nimport { getName } from './node';\nimport { Fragments, Variables } from '../types';\n\nconst isFragmentNode = (node: DefinitionNode): node is FragmentDefinitionNode =>\n  node.kind === Kind.FRAGMENT_DEFINITION;\n\n/** Returns the main operation's definition */\nexport const getMainOperation = (\n  doc: DocumentNode\n): OperationDefinitionNode => {\n  const operation = doc.definitions.find(\n    node => node.kind === Kind.OPERATION_DEFINITION\n  ) as OperationDefinitionNode;\n\n  invariant(\n    !!operation,\n    'Invalid GraphQL document: All GraphQL documents must contain an OperationDefinition' +\n      'node for a query, subscription, or mutation.',\n    1\n  );\n\n  return operation;\n};\n\n/** Returns a mapping from fragment names to their selections */\nexport const getFragments = (doc: DocumentNode): Fragments =>\n  doc.definitions.filter(isFragmentNode).reduce((map: Fragments, node) => {\n    map[getName(node)] = node;\n    return map;\n  }, {});\n\nexport const shouldInclude = (\n  node: SelectionNode,\n  vars: Variables\n): boolean => {\n  const { directives } = node;\n  if (directives === undefined) {\n    return true;\n  }\n\n  // Finds any @include or @skip directive that forces the node to be skipped\n  for (let i = 0, l = directives.length; i < l; i++) {\n    const directive = directives[i];\n    const name = getName(directive);\n\n    // Ignore other directives\n    const isInclude = name === 'include';\n    if (!isInclude && name !== 'skip') continue;\n\n    // Get the first argument and expect it to be named \"if\"\n    const arg = directive.arguments ? directive.arguments[0] : null;\n    if (!arg || getName(arg) !== 'if') continue;\n\n    const value = valueFromASTUntyped(arg.value, vars);\n    if (typeof value !== 'boolean' && value !== null) continue;\n\n    // Return whether this directive forces us to skip\n    // `@include(if: false)` or `@skip(if: true)`\n    return isInclude ? !!value : !value;\n  }\n\n  return true;\n};\n","import { FieldNode, DocumentNode, FragmentDefinitionNode } from 'graphql';\nimport { action } from 'mobx';\nimport {\n  getFragments,\n  getMainOperation,\n  getSelectionSet,\n  normalizeVariables,\n  getName,\n  getFieldArguments,\n  getFieldAlias,\n  getFragmentTypeName,\n} from '../ast';\n\nimport {\n  Fragments,\n  Variables,\n  Data,\n  DataField,\n  Link,\n  SelectionSet,\n  OperationRequest,\n  NullArray,\n} from '../types';\n\nimport {\n  Store,\n  getCurrentDependencies,\n  initDataState,\n  // clearDataState,\n  makeDict,\n  joinKeys,\n  keyOfField,\n} from '../store';\n\nimport * as InMemoryData from '../store/data';\nimport { warn, pushDebugNode } from '../helpers/help';\nimport { SelectionIterator, ensureData } from './shared';\nimport { SchemaPredicates } from '../ast';\n\nexport interface QueryResult {\n  dependencies: Set<string>;\n  partial: boolean;\n  data: null | Data;\n}\n\ninterface Context {\n  parentTypeName: string;\n  parentKey: string;\n  parentFieldKey: string;\n  fieldName: string;\n  partial: boolean;\n  store: Store;\n  variables: Variables;\n  fragments: Fragments;\n  schemaPredicates?: SchemaPredicates;\n}\n\nexport const query = (\n  store: Store,\n  request: OperationRequest,\n  data?: Data\n): QueryResult => {\n  initDataState(store.data, 0);\n  const result = read(store, request, data);\n  // clearDataState();\n  return result;\n};\n\nexport const read = (\n  store: Store,\n  request: OperationRequest,\n  input?: Data\n): QueryResult => {\n  const operation = getMainOperation(request.query);\n  const rootKey = store.getRootKey(operation.operation);\n  const rootSelect = getSelectionSet(operation);\n\n  const ctx: Context = {\n    parentTypeName: rootKey,\n    parentKey: rootKey,\n    parentFieldKey: '',\n    fieldName: '',\n    variables: normalizeVariables(operation, request.variables),\n    fragments: getFragments(request.query),\n    partial: false,\n    store,\n    schemaPredicates: store.schemaPredicates,\n  };\n\n  if (process.env.NODE_ENV !== 'production') {\n    pushDebugNode(rootKey, operation);\n  }\n\n  let data = input || makeDict();\n  data =\n    rootKey !== ctx.store.getRootKey('query')\n      ? readRoot(ctx, rootKey, rootSelect, data)\n      : readSelection(ctx, rootKey, rootSelect, data);\n\n  return {\n    dependencies: getCurrentDependencies(),\n    partial: data === undefined ? false : ctx.partial,\n    data: data === undefined ? null : data,\n  };\n};\n\nconst readRoot = (\n  ctx: Context,\n  entityKey: string,\n  select: SelectionSet,\n  originalData: Data\n): Data => {\n  if (typeof originalData.__typename !== 'string') {\n    return originalData;\n  }\n\n  const iter = new SelectionIterator(entityKey, entityKey, select, ctx);\n  const data = makeDict();\n  data.__typename = originalData.__typename;\n\n  let node: FieldNode | void;\n  while ((node = iter.next()) !== undefined) {\n    const fieldAlias = getFieldAlias(node);\n    const fieldValue = originalData[fieldAlias];\n    if (node.selectionSet !== undefined && fieldValue !== null) {\n      const fieldData = ensureData(fieldValue);\n      data[fieldAlias] = readRootField(ctx, getSelectionSet(node), fieldData);\n    } else {\n      data[fieldAlias] = fieldValue;\n    }\n  }\n\n  return data;\n};\n\nconst readRootField = (\n  ctx: Context,\n  select: SelectionSet,\n  originalData: null | Data | NullArray<Data>\n): Data | NullArray<Data> | null => {\n  if (Array.isArray(originalData)) {\n    const newData = new Array(originalData.length);\n    for (let i = 0, l = originalData.length; i < l; i++)\n      newData[i] = readRootField(ctx, select, originalData[i]);\n    return newData;\n  } else if (originalData === null) {\n    return null;\n  }\n\n  // Write entity to key that falls back to the given parentFieldKey\n  const entityKey = ctx.store.keyOfEntity(originalData);\n  if (entityKey !== null) {\n    // We assume that since this is used for result data this can never be undefined,\n    // since the result data has already been written to the cache\n    const fieldValue = readSelection(ctx, entityKey, select, makeDict());\n    return fieldValue === undefined ? null : fieldValue;\n  } else {\n    return readRoot(ctx, originalData.__typename, select, originalData);\n  }\n};\n\nexport const readFragment = (\n  store: Store,\n  query: DocumentNode,\n  entity: Data | string,\n  variables?: Variables\n): Data | null => {\n  const fragments = getFragments(query);\n  const names = Object.keys(fragments);\n  const fragment = fragments[names[0]] as FragmentDefinitionNode;\n  if (fragment === undefined) {\n    warn(\n      'readFragment(...) was called with an empty fragment.\\n' +\n        'You have to call it with at least one fragment in your GraphQL document.',\n      6\n    );\n\n    return null;\n  }\n\n  const typename = getFragmentTypeName(fragment);\n  if (typeof entity !== 'string' && !entity.__typename) {\n    entity.__typename = typename;\n  }\n\n  const entityKey =\n    typeof entity !== 'string'\n      ? store.keyOfEntity({ __typename: typename, ...entity } as Data)\n      : entity;\n\n  if (!entityKey) {\n    warn(\n      \"Can't generate a key for readFragment(...).\\n\" +\n        'You have to pass an `id` or `_id` field or create a custom `keys` config for `' +\n        typename +\n        '`.',\n      7\n    );\n\n    return null;\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    pushDebugNode(typename, fragment);\n  }\n\n  const ctx: Context = {\n    parentTypeName: typename,\n    parentKey: entityKey,\n    parentFieldKey: '',\n    fieldName: '',\n    variables: variables || {},\n    fragments,\n    partial: false,\n    store,\n    schemaPredicates: store.schemaPredicates,\n  };\n\n  return (\n    readSelection(ctx, entityKey, getSelectionSet(fragment), makeDict()) || null\n  );\n};\n\nconst readSelection = action(\n  (\n    ctx: Context,\n    entityKey: string,\n    select: SelectionSet,\n    data: Data\n  ): Data | undefined => {\n    const { store, schemaPredicates } = ctx;\n    const isQuery = entityKey === store.getRootKey('query');\n\n    // Get the __typename field for a given entity to check that it exists\n    const typename = !isQuery\n      ? InMemoryData.readRecord(entityKey, '__typename')\n      : entityKey;\n    if (typeof typename !== 'string') {\n      return undefined;\n    }\n\n    data.__typename = typename;\n    const iter = new SelectionIterator(typename, entityKey, select, ctx);\n\n    let node: FieldNode | void;\n    let hasFields = false;\n    let hasPartials = false;\n    while ((node = iter.next()) !== undefined) {\n      // Derive the needed data from our node.\n      const fieldName = getName(node);\n      const fieldArgs = getFieldArguments(node, ctx.variables);\n      const fieldAlias = getFieldAlias(node);\n      const fieldKey = keyOfField(fieldName, fieldArgs);\n      const fieldValue = InMemoryData.readRecord(entityKey, fieldKey);\n      const fieldParent = InMemoryData.readParent(entityKey, fieldKey);\n      const key = joinKeys(entityKey, fieldKey);\n      let pleaseDontAssign = false;\n\n      if (\n        process.env.NODE_ENV !== 'production' &&\n        schemaPredicates &&\n        typename\n      ) {\n        schemaPredicates.isFieldAvailableOnType(typename, fieldName);\n      }\n\n      // We temporarily store the data field in here, but undefined\n      // means that the value is missing from the cache\n      let dataFieldValue: void | DataField;\n\n      const resolvers = store.resolvers[typename];\n      if (\n        resolvers !== undefined &&\n        typeof resolvers[fieldName] === 'function'\n      ) {\n        // We have to update the information in context to reflect the info\n        // that the resolver will receive\n        ctx.parentTypeName = typename;\n        ctx.parentKey = entityKey;\n        ctx.parentFieldKey = key;\n        ctx.fieldName = fieldName;\n\n        // We have a resolver for this field.\n        // Prepare the actual fieldValue, so that the resolver can use it\n        if (fieldValue !== undefined) {\n          data[fieldAlias] = fieldValue;\n        }\n\n        dataFieldValue = resolvers[fieldName](\n          data,\n          fieldArgs || makeDict(),\n          store,\n          ctx\n        );\n\n        if (node.selectionSet !== undefined) {\n          // When it has a selection set we are resolving an entity with a\n          // subselection. This can either be a list or an object.\n          dataFieldValue = resolveResolverResult(\n            ctx,\n            typename,\n            fieldName,\n            key,\n            getSelectionSet(node),\n            (data[fieldAlias] as Data) || makeDict(),\n            dataFieldValue\n          );\n        }\n\n        if (\n          schemaPredicates !== undefined &&\n          dataFieldValue === null &&\n          !schemaPredicates.isFieldNullable(typename, fieldName)\n        ) {\n          // Special case for when null is not a valid value for the\n          // current field\n          return undefined;\n        }\n      } else if (node.selectionSet === undefined) {\n        // The field is a scalar and can be retrieved directly\n        dataFieldValue = fieldValue;\n        pleaseDontAssign = true;\n        if (data[fieldAlias] === undefined) {\n          Object.defineProperty(data, fieldAlias, {\n            get: () => {\n              return fieldParent !== null && fieldParent !== undefined\n                ? fieldParent[fieldAlias]\n                : undefined;\n            },\n          });\n        }\n      } else {\n        // We have a selection set which means that we'll be checking for links\n        const link = InMemoryData.readLink(entityKey, fieldKey);\n        if (link !== undefined) {\n          dataFieldValue = resolveLink(\n            ctx,\n            link,\n            typename,\n            fieldName,\n            getSelectionSet(node),\n            data[fieldAlias] as Data\n          );\n\n          if (data[fieldAlias] === undefined) {\n            pleaseDontAssign = true;\n            const localNode = node;\n            const localTypeName = typename;\n            Object.defineProperty(data, fieldAlias, {\n              get: () => {\n                const localLink = InMemoryData.readLink(entityKey, fieldKey);\n                if (!localLink) {\n                  return undefined;\n                }\n\n                const linkedEntity = resolveLink(\n                  ctx,\n                  localLink,\n                  localTypeName,\n                  fieldName,\n                  getSelectionSet(localNode),\n                  undefined\n                );\n                return linkedEntity !== null && linkedEntity !== undefined\n                  ? linkedEntity\n                  : undefined;\n              },\n            });\n          }\n        } else if (typeof fieldValue === 'object' && fieldValue !== null) {\n          // The entity on the field was invalid but can still be recovered\n          dataFieldValue = fieldValue;\n        }\n      }\n\n      // Now that dataFieldValue has been retrieved it'll be set on data\n      // If it's uncached (undefined) but nullable we can continue assembling\n      // a partial query result\n      if (\n        dataFieldValue === undefined &&\n        schemaPredicates !== undefined &&\n        schemaPredicates.isFieldNullable(typename, fieldName)\n      ) {\n        // The field is uncached but we have a schema that says it's nullable\n        // Set the field to null and continue\n        hasPartials = true;\n        data[fieldAlias] = null;\n      } else if (dataFieldValue === undefined) {\n        // The field is uncached and not nullable; return undefined\n        return undefined;\n      } else {\n        // Otherwise continue as usual\n        hasFields = true;\n        if (pleaseDontAssign === false) {\n          data[fieldAlias] = dataFieldValue;\n        }\n      }\n    }\n\n    if (hasPartials) ctx.partial = true;\n    return isQuery && hasPartials && !hasFields ? undefined : data;\n  }\n);\n\nconst readResolverResult = (\n  ctx: Context,\n  key: string,\n  select: SelectionSet,\n  data: Data,\n  result: Data\n): Data | undefined => {\n  const { store, schemaPredicates } = ctx;\n  const entityKey = store.keyOfEntity(result) || key;\n  const resolvedTypename = result.__typename;\n  const typename =\n    InMemoryData.readRecord(entityKey, '__typename') || resolvedTypename;\n\n  if (\n    typeof typename !== 'string' ||\n    (resolvedTypename && typename !== resolvedTypename)\n  ) {\n    // TODO: This may be an invalid error for resolvers that return interfaces\n    warn(\n      'Invalid resolver data: The resolver at `' +\n        entityKey +\n        '` returned an ' +\n        'invalid typename that could not be reconciled with the cache.',\n      8\n    );\n\n    return undefined;\n  }\n\n  // The following closely mirrors readSelection, but differs only slightly for the\n  // sake of resolving from an existing resolver result\n  data.__typename = typename;\n  const iter = new SelectionIterator(typename, entityKey, select, ctx);\n\n  let node: FieldNode | void;\n  let hasFields = false;\n  let hasPartials = false;\n  while ((node = iter.next()) !== undefined) {\n    // Derive the needed data from our node.\n    const fieldName = getName(node);\n    const fieldAlias = getFieldAlias(node);\n    const fieldKey = keyOfField(\n      fieldName,\n      getFieldArguments(node, ctx.variables)\n    );\n    const key = joinKeys(entityKey, fieldKey);\n    const fieldValue = InMemoryData.readRecord(entityKey, fieldKey);\n    const resultValue = result[fieldName];\n\n    if (process.env.NODE_ENV !== 'production' && schemaPredicates && typename) {\n      schemaPredicates.isFieldAvailableOnType(typename, fieldName);\n    }\n\n    // We temporarily store the data field in here, but undefined\n    // means that the value is missing from the cache\n    let dataFieldValue: void | DataField;\n    if (resultValue !== undefined && node.selectionSet === undefined) {\n      // The field is a scalar and can be retrieved directly from the result\n      dataFieldValue = resultValue;\n    } else if (node.selectionSet === undefined) {\n      // The field is a scalar but isn't on the result, so it's retrieved from the cache\n      dataFieldValue = fieldValue;\n    } else if (resultValue !== undefined) {\n      // We start walking the nested resolver result here\n      dataFieldValue = resolveResolverResult(\n        ctx,\n        typename,\n        fieldName,\n        key,\n        getSelectionSet(node),\n        data[fieldAlias] as Data,\n        resultValue\n      );\n    } else {\n      // Otherwise we attempt to get the missing field from the cache\n      const link = InMemoryData.readLink(entityKey, fieldKey);\n\n      if (link !== undefined) {\n        dataFieldValue = resolveLink(\n          ctx,\n          link,\n          typename,\n          fieldName,\n          getSelectionSet(node),\n          data[fieldAlias] as Data\n        );\n      } else if (typeof fieldValue === 'object' && fieldValue !== null) {\n        // The entity on the field was invalid but can still be recovered\n        dataFieldValue = fieldValue;\n      }\n    }\n\n    // Now that dataFieldValue has been retrieved it'll be set on data\n    // If it's uncached (undefined) but nullable we can continue assembling\n    // a partial query result\n    if (\n      dataFieldValue === undefined &&\n      schemaPredicates !== undefined &&\n      schemaPredicates.isFieldNullable(typename, fieldName)\n    ) {\n      // The field is uncached but we have a schema that says it's nullable\n      // Set the field to null and continue\n      hasPartials = true;\n      data[fieldAlias] = null;\n    } else if (dataFieldValue === undefined) {\n      // The field is uncached and not nullable; return undefined\n      return undefined;\n    } else {\n      // Otherwise continue as usual\n      hasFields = true;\n      data[fieldAlias] = dataFieldValue;\n    }\n  }\n\n  if (hasPartials) ctx.partial = true;\n  return !hasFields ? undefined : data;\n};\n\nconst resolveResolverResult = (\n  ctx: Context,\n  typename: string,\n  fieldName: string,\n  key: string,\n  select: SelectionSet,\n  prevData: void | Data | Data[],\n  result: void | DataField\n): DataField | void => {\n  if (Array.isArray(result)) {\n    const { schemaPredicates } = ctx;\n    // Check whether values of the list may be null; for resolvers we assume\n    // that they can be, since it's user-provided data\n    const isListNullable =\n      schemaPredicates === undefined ||\n      schemaPredicates.isListNullable(typename, fieldName);\n    const data = new Array(result.length);\n    for (let i = 0, l = result.length; i < l; i++) {\n      // Recursively read resolver result\n      const childResult = resolveResolverResult(\n        ctx,\n        typename,\n        fieldName,\n        joinKeys(key, `${i}`),\n        select,\n        // Get the inner previous data from prevData\n        prevData !== undefined ? prevData[i] : undefined,\n        result[i]\n      );\n\n      if (childResult === undefined && !isListNullable) {\n        return undefined;\n      } else {\n        data[i] = childResult !== undefined ? childResult : null;\n      }\n    }\n\n    return data;\n  } else if (result === null || result === undefined) {\n    return result;\n  } else if (isDataOrKey(result)) {\n    const data = prevData === undefined ? makeDict() : prevData;\n    return typeof result === 'string'\n      ? readSelection(ctx, result, select, data)\n      : readResolverResult(ctx, key, select, data, result);\n  } else {\n    warn(\n      'Invalid resolver value: The field at `' +\n        key +\n        '` is a scalar (number, boolean, etc)' +\n        ', but the GraphQL query expects a selection set for this field.',\n      9\n    );\n\n    return undefined;\n  }\n};\n\nconst resolveLink = (\n  ctx: Context,\n  link: Link | Link[],\n  typename: string,\n  fieldName: string,\n  select: SelectionSet,\n  prevData: void | Data | Data[]\n): DataField | undefined => {\n  if (Array.isArray(link)) {\n    const { schemaPredicates } = ctx;\n    const isListNullable =\n      schemaPredicates !== undefined &&\n      schemaPredicates.isListNullable(typename, fieldName);\n    const newLink = new Array(link.length);\n    for (let i = 0, l = link.length; i < l; i++) {\n      const childLink = resolveLink(\n        ctx,\n        link[i],\n        typename,\n        fieldName,\n        select,\n        prevData !== undefined ? prevData[i] : undefined\n      );\n      if (childLink === undefined && !isListNullable) {\n        return undefined;\n      } else {\n        newLink[i] = childLink !== undefined ? childLink : null;\n      }\n    }\n\n    return newLink;\n  } else if (link === null) {\n    return null;\n  } else {\n    // console.log({link, prevData})\n    return readSelection(\n      ctx,\n      link,\n      select,\n      prevData === undefined ? makeDict() : prevData\n    );\n  }\n};\n\nconst isDataOrKey = (x: any): x is string | Data =>\n  typeof x === 'string' ||\n  (typeof x === 'object' && typeof (x as any).__typename === 'string');\n","import { IntrospectionQuery } from 'graphql';\n\nimport {\n  Exchange,\n  formatDocument,\n  Operation,\n  OperationResult,\n  RequestPolicy,\n  CacheOutcome,\n} from 'urql/core';\n\nimport {\n  filter,\n  map,\n  merge,\n  pipe,\n  share,\n  tap,\n  fromPromise,\n  fromArray,\n  buffer,\n  take,\n  mergeMap,\n  concat,\n  empty,\n  Source,\n} from 'wonka';\n\nimport { query, write, writeOptimistic } from './operations';\nimport { SchemaPredicates } from './ast';\nimport { hydrateData } from './store/data';\nimport { makeDict, Store, clearOptimistic } from './store';\n\nimport {\n  UpdatesConfig,\n  ResolverConfig,\n  OptimisticMutationConfig,\n  KeyingConfig,\n  StorageAdapter,\n} from './types';\n\ntype OperationResultWithMeta = OperationResult & {\n  outcome: CacheOutcome;\n};\n\ntype OperationMap = Map<number, Operation>;\n\ninterface DependentOperations {\n  [key: string]: number[];\n}\n\n// Returns the given operation result with added cacheOutcome meta field\nconst addCacheOutcome = (op: Operation, outcome: CacheOutcome): Operation => ({\n  ...op,\n  context: {\n    ...op.context,\n    meta: {\n      ...op.context.meta,\n      cacheOutcome: outcome,\n    },\n  },\n});\n\n// Returns the given operation with added __typename fields on its query\nconst addTypeNames = (op: Operation): Operation => ({\n  ...op,\n  query: formatDocument(op.query),\n});\n\n// Retrieves the requestPolicy from an operation\nconst getRequestPolicy = (op: Operation) => op.context.requestPolicy;\n\n// Returns whether an operation is a query\nconst isQueryOperation = (op: Operation): boolean =>\n  op.operationName === 'query';\n\n// Returns whether an operation is a mutation\nconst isMutationOperation = (op: Operation): boolean =>\n  op.operationName === 'mutation';\n\n// Returns whether an operation can potentially be read from cache\nconst isCacheableQuery = (op: Operation): boolean => {\n  return isQueryOperation(op) && getRequestPolicy(op) !== 'network-only';\n};\n\n// Returns whether an operation potentially triggers an optimistic update\nconst isOptimisticMutation = (op: Operation): boolean => {\n  return isMutationOperation(op) && getRequestPolicy(op) !== 'network-only';\n};\n\n// Copy an operation and change the requestPolicy to skip the cache\nconst toRequestPolicy = (\n  operation: Operation,\n  requestPolicy: RequestPolicy\n): Operation => ({\n  ...operation,\n  context: {\n    ...operation.context,\n    requestPolicy,\n  },\n});\n\nexport interface CacheExchangeOpts {\n  updates?: Partial<UpdatesConfig>;\n  resolvers?: ResolverConfig;\n  optimistic?: OptimisticMutationConfig;\n  keys?: KeyingConfig;\n  schema?: IntrospectionQuery;\n  storage?: StorageAdapter;\n}\n\nexport const cacheExchange = (opts?: CacheExchangeOpts): Exchange => ({\n  forward,\n  client,\n}) => {\n  if (!opts) opts = {};\n\n  const store = new Store(\n    opts.schema ? new SchemaPredicates(opts.schema) : undefined,\n    opts.resolvers,\n    opts.updates,\n    opts.optimistic,\n    opts.keys\n  );\n\n  let hydration: void | Promise<void>;\n  if (opts.storage) {\n    const storage = opts.storage;\n    hydration = storage.read().then(entries => {\n      hydrateData(store.data, storage, entries);\n    });\n  }\n\n  const optimisticKeysToDependencies = new Map<number, Set<string>>();\n  const ops: OperationMap = new Map();\n  const deps: DependentOperations = makeDict();\n\n  const collectPendingOperations = (\n    pendingOperations: Set<number>,\n    dependencies: void | Set<string>\n  ) => {\n    if (dependencies !== undefined) {\n      // Collect operations that will be updated due to cache changes\n      dependencies.forEach(dep => {\n        const keys = deps[dep];\n        if (keys !== undefined) {\n          deps[dep] = [];\n          for (let i = 0, l = keys.length; i < l; i++) {\n            pendingOperations.add(keys[i]);\n          }\n        }\n      });\n    }\n  };\n\n  const executePendingOperations = (\n    operation: Operation,\n    pendingOperations: Set<number>\n  ) => {\n    // Reexecute collected operations and delete them from the mapping\n    pendingOperations.forEach(key => {\n      if (key !== operation.key) {\n        const op = ops.get(key);\n        if (op !== undefined) {\n          ops.delete(key);\n          client.reexecuteOperation(toRequestPolicy(op, 'cache-first'));\n        }\n      }\n    });\n  };\n\n  // This executes an optimistic update for mutations and registers it if necessary\n  const optimisticUpdate = (operation: Operation) => {\n    if (isOptimisticMutation(operation)) {\n      const { key } = operation;\n      const { dependencies } = writeOptimistic(store, operation, key);\n      if (dependencies.size !== 0) {\n        optimisticKeysToDependencies.set(key, dependencies);\n        const pendingOperations = new Set<number>();\n        collectPendingOperations(pendingOperations, dependencies);\n        executePendingOperations(operation, pendingOperations);\n      }\n    }\n  };\n\n  // This updates the known dependencies for the passed operation\n  const updateDependencies = (op: Operation, dependencies: Set<string>) => {\n    dependencies.forEach(dep => {\n      const keys = deps[dep] || (deps[dep] = []);\n      keys.push(op.key);\n\n      if (!ops.has(op.key)) {\n        ops.set(\n          op.key,\n          getRequestPolicy(op) === 'network-only'\n            ? toRequestPolicy(op, 'cache-and-network')\n            : op\n        );\n      }\n    });\n  };\n\n  // Retrieves a query result from cache and adds an `isComplete` hint\n  // This hint indicates whether the result is \"complete\" or not\n  const operationResultFromCache = (\n    operation: Operation\n  ): OperationResultWithMeta => {\n    const { data, dependencies, partial } = query(store, operation);\n    let cacheOutcome: CacheOutcome;\n\n    if (data === null) {\n      cacheOutcome = 'miss';\n    } else {\n      updateDependencies(operation, dependencies);\n      cacheOutcome =\n        !partial || getRequestPolicy(operation) === 'cache-only'\n          ? 'hit'\n          : 'partial';\n    }\n\n    return {\n      outcome: cacheOutcome,\n      operation,\n      data,\n    };\n  };\n\n  // Take any OperationResult and update the cache with it\n  const updateCacheWithResult = (result: OperationResult): OperationResult => {\n    const { operation, error, extensions } = result;\n    const isQuery = isQueryOperation(operation);\n    let { data } = result;\n\n    // Clear old optimistic values from the store\n    const { key } = operation;\n    const pendingOperations = new Set<number>();\n    collectPendingOperations(\n      pendingOperations,\n      optimisticKeysToDependencies.get(key)\n    );\n    optimisticKeysToDependencies.delete(key);\n    clearOptimistic(store.data, key);\n\n    let writeDependencies: Set<string> | void;\n    let queryDependencies: Set<string> | void;\n    if (data !== null && data !== undefined) {\n      writeDependencies = write(store, operation, data).dependencies;\n\n      if (isQuery) {\n        const queryResult = query(store, operation);\n        data = queryResult.data;\n        queryDependencies = queryResult.dependencies;\n      } else {\n        data = query(store, operation, data).data;\n      }\n    }\n\n    // Collect all write dependencies and query dependencies for queries\n    collectPendingOperations(pendingOperations, writeDependencies);\n    if (isQuery) {\n      collectPendingOperations(pendingOperations, queryDependencies);\n    }\n\n    // Execute all pending operations related to changed dependencies\n    executePendingOperations(result.operation, pendingOperations);\n\n    // Update this operation's dependencies if it's a query\n    if (isQuery && queryDependencies !== undefined) {\n      updateDependencies(result.operation, queryDependencies);\n    }\n\n    return { data, error, extensions, operation };\n  };\n\n  return ops$ => {\n    const sharedOps$ = pipe(ops$, share);\n\n    // Buffer operations while waiting on hydration to finish\n    // If no hydration takes place we replace this stream with an empty one\n    const bufferedOps$ = hydration\n      ? pipe(\n          sharedOps$,\n          buffer(fromPromise(hydration)),\n          take(1),\n          mergeMap(fromArray)\n        )\n      : (empty as Source<Operation>);\n\n    const inputOps$ = pipe(\n      concat([bufferedOps$, sharedOps$]),\n      map(addTypeNames),\n      tap(optimisticUpdate),\n      share\n    );\n\n    // Filter by operations that are cacheable and attempt to query them from the cache\n    const cache$ = pipe(\n      inputOps$,\n      filter(op => isCacheableQuery(op)),\n      map(operationResultFromCache),\n      share\n    );\n\n    // Rebound operations that are incomplete, i.e. couldn't be queried just from the cache\n    const cacheOps$ = pipe(\n      cache$,\n      filter(res => res.outcome === 'miss'),\n      map(res => addCacheOutcome(res.operation, res.outcome))\n    );\n\n    // Resolve OperationResults that the cache was able to assemble completely and trigger\n    // a network request if the current operation's policy is cache-and-network\n    const cacheResult$ = pipe(\n      cache$,\n      filter(res => res.outcome !== 'miss'),\n      map(\n        (res: OperationResultWithMeta): OperationResult => {\n          const { operation, outcome } = res;\n          const policy = getRequestPolicy(operation);\n          const result: OperationResult = {\n            operation: addCacheOutcome(operation, outcome),\n            data: res.data,\n            error: res.error,\n            extensions: res.extensions,\n          };\n\n          if (\n            policy === 'cache-and-network' ||\n            (policy === 'cache-first' && outcome === 'partial')\n          ) {\n            result.stale = true;\n            client.reexecuteOperation(\n              toRequestPolicy(operation, 'network-only')\n            );\n          }\n\n          return result;\n        }\n      )\n    );\n\n    // Forward operations that aren't cacheable and rebound operations\n    // Also update the cache with any network results\n    const result$ = pipe(\n      forward(\n        merge([\n          pipe(\n            inputOps$,\n            filter(op => !isCacheableQuery(op))\n          ),\n          cacheOps$,\n        ])\n      ),\n      map(updateCacheWithResult)\n    );\n\n    return merge([result$, cacheResult$]);\n  };\n};\n","import {\n  DocumentNode,\n  buildClientSchema,\n  visitWithTypeInfo,\n  TypeInfo,\n  FragmentDefinitionNode,\n  GraphQLSchema,\n  IntrospectionQuery,\n  FragmentSpreadNode,\n  NameNode,\n  ASTNode,\n  isCompositeType,\n  isAbstractType,\n  Kind,\n  visit,\n} from 'graphql';\n\nimport { pipe, tap, map } from 'wonka';\nimport { Exchange, Operation } from 'urql/core';\n\nimport { getName, getSelectionSet, unwrapType } from './ast';\nimport { makeDict } from './store';\nimport { invariant, warn } from './helpers/help';\n\ninterface PopulateExchangeOpts {\n  schema: IntrospectionQuery;\n}\n\n/** An exchange for auto-populating mutations with a required response body. */\nexport const populateExchange = ({\n  schema: ogSchema,\n}: PopulateExchangeOpts): Exchange => ({ forward }) => {\n  const schema = buildClientSchema(ogSchema);\n  /** List of operation keys that have already been parsed. */\n  const parsedOperations = new Set<number>();\n  /** List of operation keys that have not been torn down. */\n  const activeOperations = new Set<number>();\n  /** Collection of fragments used by the user. */\n  const userFragments: UserFragmentMap = makeDict();\n  /** Collection of actively in use type fragments. */\n  const activeTypeFragments: TypeFragmentMap = makeDict();\n\n  /** Handle mutation and inject selections + fragments. */\n  const handleIncomingMutation = (op: Operation) => {\n    if (op.operationName !== 'mutation') {\n      return op;\n    }\n\n    const activeSelections: TypeFragmentMap = makeDict();\n    for (const name in activeTypeFragments) {\n      activeSelections[name] = activeTypeFragments[name].filter(s =>\n        activeOperations.has(s.key)\n      );\n    }\n\n    return {\n      ...op,\n      query: addFragmentsToQuery(\n        schema,\n        op.query,\n        activeSelections,\n        userFragments\n      ),\n    };\n  };\n\n  /** Handle query and extract fragments. */\n  const handleIncomingQuery = ({ key, operationName, query }: Operation) => {\n    if (operationName !== 'query') {\n      return;\n    }\n\n    activeOperations.add(key);\n    if (parsedOperations.has(key)) {\n      return;\n    }\n\n    parsedOperations.add(key);\n\n    const [extractedFragments, newFragments] = extractSelectionsFromQuery(\n      schema,\n      query\n    );\n\n    for (let i = 0, l = extractedFragments.length; i < l; i++) {\n      const fragment = extractedFragments[i];\n      userFragments[getName(fragment)] = fragment;\n    }\n\n    for (let i = 0, l = newFragments.length; i < l; i++) {\n      const fragment = newFragments[i];\n      const type = getName(fragment.typeCondition);\n      const current =\n        activeTypeFragments[type] || (activeTypeFragments[type] = []);\n\n      (fragment as any).name.value += current.length;\n      current.push({ key, fragment });\n    }\n  };\n\n  const handleIncomingTeardown = ({ key, operationName }: Operation) => {\n    if (operationName === 'teardown') {\n      activeOperations.delete(key);\n    }\n  };\n\n  return ops$ => {\n    return pipe(\n      ops$,\n      tap(handleIncomingQuery),\n      tap(handleIncomingTeardown),\n      map(handleIncomingMutation),\n      forward\n    );\n  };\n};\n\ntype UserFragmentMap<T extends string = string> = Record<\n  T,\n  FragmentDefinitionNode\n>;\n\ntype TypeFragmentMap<T extends string = string> = Record<T, TypeFragment[]>;\n\ninterface TypeFragment {\n  /** Operation key where selection set is being used. */\n  key: number;\n  /** Selection set. */\n  fragment: FragmentDefinitionNode;\n}\n\n/** Gets typed selection sets and fragments from query */\nexport const extractSelectionsFromQuery = (\n  schema: GraphQLSchema,\n  query: DocumentNode\n) => {\n  const extractedFragments: FragmentDefinitionNode[] = [];\n  const newFragments: FragmentDefinitionNode[] = [];\n  const typeInfo = new TypeInfo(schema);\n\n  visit(\n    query,\n    visitWithTypeInfo(typeInfo, {\n      Field: node => {\n        if (node.selectionSet) {\n          const type = getTypeName(typeInfo);\n          newFragments.push({\n            kind: Kind.FRAGMENT_DEFINITION,\n            typeCondition: {\n              kind: Kind.NAMED_TYPE,\n              name: nameNode(type),\n            },\n            name: nameNode(`${type}_PopulateFragment_`),\n            selectionSet: node.selectionSet,\n          });\n        }\n      },\n      FragmentDefinition: node => {\n        extractedFragments.push(node);\n      },\n    })\n  );\n\n  return [extractedFragments, newFragments];\n};\n\n/** Replaces populate decorator with fragment spreads + fragments. */\nexport const addFragmentsToQuery = (\n  schema: GraphQLSchema,\n  query: DocumentNode,\n  activeTypeFragments: TypeFragmentMap,\n  userFragments: UserFragmentMap\n) => {\n  const typeInfo = new TypeInfo(schema);\n\n  const requiredUserFragments: Record<\n    string,\n    FragmentDefinitionNode\n  > = makeDict();\n\n  const additionalFragments: Record<\n    string,\n    FragmentDefinitionNode\n  > = makeDict();\n\n  /** Fragments provided and used by the current query */\n  const existingFragmentsForQuery: Set<string> = new Set();\n\n  return visit(\n    query,\n    visitWithTypeInfo(typeInfo, {\n      Field: {\n        enter: node => {\n          if (!node.directives) {\n            return;\n          }\n\n          const directives = node.directives.filter(\n            d => getName(d) !== 'populate'\n          );\n          if (directives.length === node.directives.length) {\n            return;\n          }\n\n          const possibleTypes = getTypes(schema, typeInfo);\n          const newSelections = possibleTypes.reduce((p, possibleType) => {\n            const typeFrags = activeTypeFragments[possibleType.name];\n            if (!typeFrags) {\n              return p;\n            }\n\n            for (let i = 0, l = typeFrags.length; i < l; i++) {\n              const { fragment } = typeFrags[i];\n              const fragmentName = getName(fragment);\n              const usedFragments = getUsedFragments(fragment);\n\n              // Add used fragment for insertion at Document node\n              for (let j = 0, l = usedFragments.length; j < l; j++) {\n                const name = usedFragments[j];\n                if (!existingFragmentsForQuery.has(name)) {\n                  requiredUserFragments[name] = userFragments[name];\n                }\n              }\n\n              // Add fragment for insertion at Document node\n              additionalFragments[fragmentName] = fragment;\n\n              p.push({\n                kind: Kind.FRAGMENT_SPREAD,\n                name: nameNode(fragmentName),\n              });\n            }\n\n            return p;\n          }, [] as FragmentSpreadNode[]);\n\n          const existingSelections = getSelectionSet(node);\n\n          const selections =\n            existingSelections.length + newSelections.length !== 0\n              ? [...newSelections, ...existingSelections]\n              : [\n                  {\n                    kind: Kind.FIELD,\n                    name: nameNode('__typename'),\n                  },\n                ];\n\n          return {\n            ...node,\n            directives,\n            selectionSet: {\n              kind: Kind.SELECTION_SET,\n              selections,\n            },\n          };\n        },\n      },\n      Document: {\n        enter: node => {\n          node.definitions.reduce((set, definition) => {\n            if (definition.kind === 'FragmentDefinition') {\n              set.add(definition.name.value);\n            }\n            return set;\n          }, existingFragmentsForQuery);\n        },\n        leave: node => {\n          const definitions = [...node.definitions];\n          for (const key in additionalFragments)\n            definitions.push(additionalFragments[key]);\n          for (const key in requiredUserFragments)\n            definitions.push(requiredUserFragments[key]);\n          return { ...node, definitions };\n        },\n      },\n    })\n  );\n};\n\nconst nameNode = (value: string): NameNode => ({\n  kind: Kind.NAME,\n  value,\n});\n\n/** Get all possible types for node with TypeInfo. */\nconst getTypes = (schema: GraphQLSchema, typeInfo: TypeInfo) => {\n  const type = unwrapType(typeInfo.getType());\n  if (!isCompositeType(type)) {\n    warn(\n      'Invalid type: The type ` + type + ` is used with @populate but does not exist.',\n      17\n    );\n    return [];\n  }\n\n  return isAbstractType(type) ? schema.getPossibleTypes(type) : [type];\n};\n\n/** Get name of non-abstract type for adding to 'activeTypeFragments'. */\nconst getTypeName = (typeInfo: TypeInfo) => {\n  const type = unwrapType(typeInfo.getType());\n  invariant(\n    type && !isAbstractType(type),\n    'Invalid TypeInfo state: Found no flat schema type when one was expected.',\n    18\n  );\n\n  return type.toString();\n};\n\n/** Get fragment names referenced by node. */\nconst getUsedFragments = (node: ASTNode) => {\n  const names: string[] = [];\n\n  visit(node, {\n    FragmentSpread: f => {\n      names.push(getName(f));\n    },\n  });\n\n  return names;\n};\n"],"names":["const","getName","node","name","value","getFragmentTypeName","typeCondition","getFieldAlias","alias","undefined","getSelectionSet","selectionSet","selections","getTypeCondition","ref","isFieldNode","kind","Kind","FIELD","isInlineFragment","INLINE_FRAGMENT","unwrapType","type","isWrappingType","ofType","helpUrl","cache","Set","currentDebugStack","pushDebugNode","typename","identifier","let","OPERATION_DEFINITION","operation","FRAGMENT_DEFINITION","push","getDebugOutput","length","join","invariant","condition","message","code","errorMessage","process","env","NODE_ENV","error","Error","warn","has","console","add","keyOfField","fieldName","args","stringifyVariables","fieldInfoOfKey","fieldKey","parenIndex","indexOf","slice","arguments","JSON","parse","joinKeys","parentKey","key","prefixKey","owner","defer","Promise","prototype","then","bind","resolve","fn","setTimeout","makeDict","observable","currentData","currentDependencies","currentOptimisticKey","makeNodeMap","optimistic","base","Map","keys","initDataState","data","optimisticKey","window","clearDataState","gc","gcScheduled","gcBatch","size","storage","write","persistenceBatch","persistenceScheduled","getCurrentDependencies","make","queryRootKey","refCount","refLock","links","records","setNode","map","entityKey","keymap","unshift","entity","get","set","getNode","i","l","getNodeParent","clearOptimisticNodes","index","splice","updateRCForEntity","by","count","newCount","delete","updateRCForLink","link","Array","isArray","extractNodeFields","fieldInfos","seenFieldKeys","extractNodeMapFields","forEach","rc","locks","recordsNode","linkNode","updateDependencies","readRecord","readParent","readLink","writeRecord","action","hasField","writeLink","prevLinkNode","prevLink","clearOptimistic","inspectFields","hydrateData","entries","dotIndex","charCodeAt","isFragmentHeuristicallyMatching","ctx","some","getFieldArguments","variables","SelectionIterator","select","context","indexStack","selectionStack","next","pop","shouldInclude","fragmentNode","fragments","isMatching","schemaPredicates","isInterfaceOfType","ensureData","x","store","request","result","startWrite","getMainOperation","query","dependencies","operationName","getRootKey","parentTypeName","parentFieldKey","normalizeVariables","getFragments","writeSelection","writeRoot","writeOptimistic","mutationRootKey","iter","resolver","optimisticMutations","fieldArgs","resolverValue","resolverData","writeRootField","updater","updates","writeFragment","names","Object","fragment","writeData","__typename","keyOfEntity","isQuery","InMemoryData","fieldValue","advice","expected","isFieldAvailableOnType","fieldData","writeField","newData","item","indexKey","endsWith","isRootField","invalidate","invalidateSelection","fieldSelect","childLink","Store","resolvers","this","Mutation","Subscription","queryType","schema","getQueryType","mutationType","getMutationType","subscriptionType","getSubscriptionType","queryName","mutationName","subscriptionName","rootFields","rootNames","id","_id","resolveFieldByKey","field","invalidateQuery","createRequest","updateQuery","input","output","readQuery","read","readFragment","dataFragment","vars","argsSize","arg","valueFromASTUntyped","variableDefinitions","reduce","def","variable","defaultValue","SchemaPredicates","buildClientSchema","isFieldNullable","getField","isNullableType","isListNullable","isNonNullType","isListType","fieldname","abstractType","getType","objectType","GraphQLObjectType","expectAbstractType","expectObjectType","isPossibleType","object","getFields","GraphQLInterfaceType","GraphQLUnionType","isFragmentNode","doc","definitions","find","filter","directives","directive","isInclude","rootKey","rootSelect","partial","readRoot","readSelection","originalData","fieldAlias","readRootField","hasFields","hasPartials","fieldParent","pleaseDontAssign","dataFieldValue","localLink","linkedEntity","resolveLink","localTypeName","localNode","resolveResolverResult","defineProperty","readResolverResult","resolvedTypename","resultValue","prevData","childResult","isDataOrKey","newLink","addCacheOutcome","op","outcome","meta","cacheOutcome","addTypeNames","formatDocument","getRequestPolicy","requestPolicy","isQueryOperation","isMutationOperation","isCacheableQuery","isOptimisticMutation","toRequestPolicy","res","cacheExchange","opts","hydration","optimisticKeysToDependencies","ops","deps","collectPendingOperations","pendingOperations","dep","executePendingOperations","client","reexecuteOperation","optimisticUpdate","operationResultFromCache","updateCacheWithResult","writeDependencies","queryDependencies","queryResult","extensions","policy","stale","ops$","sharedOps$","share","bufferedOps$","mergeMap","fromArray","take","buffer","fromPromise","empty","inputOps$","tap","concat","cache$","cacheOps$","cacheResult$","result$","forward","merge","populateExchange","ogSchema","parsedOperations","activeOperations","userFragments","activeTypeFragments","s","handleIncomingMutation","activeSelections","addFragmentsToQuery","handleIncomingQuery","extractSelectionsFromQuery","extractedFragments","newFragments","current","handleIncomingTeardown","typeInfo","TypeInfo","visit","visitWithTypeInfo","Field","getTypeName","NAMED_TYPE","nameNode","FragmentDefinition","d","definition","requiredUserFragments","additionalFragments","existingFragmentsForQuery","p","possibleType","typeFrags","fragmentName","usedFragments","getUsedFragments","j","FRAGMENT_SPREAD","enter","possibleTypes","getTypes","newSelections","existingSelections","SELECTION_SET","Document","leave","NAME","isCompositeType","isAbstractType","getPossibleTypes","toString","FragmentSpread","f"],"mappings":"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"}