{"version":3,"file":"urql-exchange-graphcache-extras.js","sources":["../src/extras/relayPagination.ts","../src/extras/simplePagination.ts"],"sourcesContent":["import { stringifyVariables } from 'urql/core';\nimport { Cache, Resolver, Variables, NullArray } from '../types';\n\nexport type MergeMode = 'outwards' | 'inwards';\n\nexport interface PaginationParams {\n  mergeMode?: MergeMode;\n}\n\ninterface PageInfo {\n  __typename: string;\n  endCursor: null | string;\n  startCursor: null | string;\n  hasNextPage: boolean;\n  hasPreviousPage: boolean;\n}\n\ninterface Page {\n  __typename: string;\n  edges: NullArray<string>;\n  pageInfo: PageInfo;\n}\n\nconst defaultPageInfo: PageInfo = {\n  __typename: 'PageInfo',\n  endCursor: null,\n  startCursor: null,\n  hasNextPage: false,\n  hasPreviousPage: false,\n};\n\nconst ensureKey = (x: any): string | null => (typeof x === 'string' ? x : null);\n\nconst concatEdges = (\n  cache: Cache,\n  leftEdges: NullArray<string>,\n  rightEdges: NullArray<string>\n) => {\n  const ids = new Set<string>();\n  for (let i = 0, l = leftEdges.length; i < l; i++) {\n    const edge = leftEdges[i];\n    const node = cache.resolve(edge, 'node');\n    if (typeof node === 'string') ids.add(node);\n  }\n\n  const newEdges = leftEdges.slice();\n  for (let i = 0, l = rightEdges.length; i < l; i++) {\n    const edge = rightEdges[i];\n    const node = cache.resolve(edge, 'node');\n    if (typeof node === 'string' && !ids.has(node)) {\n      ids.add(node);\n      newEdges.push(edge);\n    }\n  }\n\n  return newEdges;\n};\n\nconst compareArgs = (\n  fieldArgs: Variables,\n  connectionArgs: Variables\n): boolean => {\n  for (const key in connectionArgs) {\n    if (\n      key === 'first' ||\n      key === 'last' ||\n      key === 'after' ||\n      key === 'before'\n    ) {\n      continue;\n    } else if (!(key in fieldArgs)) {\n      return false;\n    }\n\n    const argA = fieldArgs[key];\n    const argB = connectionArgs[key];\n\n    if (\n      typeof argA !== typeof argB || typeof argA !== 'object'\n        ? argA !== argB\n        : stringifyVariables(argA) !== stringifyVariables(argB)\n    ) {\n      return false;\n    }\n  }\n\n  for (const key in fieldArgs) {\n    if (\n      key === 'first' ||\n      key === 'last' ||\n      key === 'after' ||\n      key === 'before'\n    ) {\n      continue;\n    }\n\n    if (!(key in connectionArgs)) return false;\n  }\n\n  return true;\n};\n\nconst getPage = (\n  cache: Cache,\n  entityKey: string,\n  fieldKey: string\n): Page | null => {\n  const link = ensureKey(cache.resolveFieldByKey(entityKey, fieldKey));\n  if (!link) return null;\n\n  const typename = cache.resolve(link, '__typename') as string;\n  const edges = (cache.resolve(link, 'edges') || []) as NullArray<string>;\n  if (typeof typename !== 'string') {\n    return null;\n  }\n\n  const page: Page = {\n    __typename: typename,\n    edges,\n    pageInfo: defaultPageInfo,\n  };\n\n  const pageInfoKey = cache.resolve(link, 'pageInfo');\n  if (typeof pageInfoKey === 'string') {\n    const pageInfoType = ensureKey(cache.resolve(pageInfoKey, '__typename'));\n    const endCursor = ensureKey(cache.resolve(pageInfoKey, 'endCursor'));\n    const startCursor = ensureKey(cache.resolve(pageInfoKey, 'startCursor'));\n    const hasNextPage = cache.resolve(pageInfoKey, 'hasNextPage');\n    const hasPreviousPage = cache.resolve(pageInfoKey, 'hasPreviousPage');\n\n    const pageInfo: PageInfo = (page.pageInfo = {\n      __typename: typeof pageInfoType === 'string' ? pageInfoType : 'PageInfo',\n      hasNextPage: typeof hasNextPage === 'boolean' ? hasNextPage : !!endCursor,\n      hasPreviousPage:\n        typeof hasPreviousPage === 'boolean' ? hasPreviousPage : !!startCursor,\n      endCursor,\n      startCursor,\n    });\n\n    if (pageInfo.endCursor === null) {\n      const edge = edges[edges.length - 1];\n      if (edge) {\n        const endCursor = cache.resolve(edge, 'cursor');\n        pageInfo.endCursor = ensureKey(endCursor);\n      }\n    }\n\n    if (pageInfo.startCursor === null) {\n      const edge = edges[0];\n      if (edge) {\n        const startCursor = cache.resolve(edge, 'cursor');\n        pageInfo.startCursor = ensureKey(startCursor);\n      }\n    }\n  }\n\n  return page;\n};\n\nexport const relayPagination = (params: PaginationParams = {}): Resolver => {\n  const mergeMode = params.mergeMode || 'inwards';\n\n  return (_parent, fieldArgs, cache, info) => {\n    const { parentKey: entityKey, fieldName } = info;\n\n    const allFields = cache.inspectFields(entityKey);\n    const fieldInfos = allFields.filter(info => info.fieldName === fieldName);\n    const size = fieldInfos.length;\n    if (size === 0) {\n      return undefined;\n    }\n\n    let typename: string | null = null;\n    let startEdges: NullArray<string> = [];\n    let endEdges: NullArray<string> = [];\n    let pageInfo: PageInfo = { ...defaultPageInfo };\n\n    for (let i = 0; i < size; i++) {\n      const { fieldKey, arguments: args } = fieldInfos[i];\n      if (args === null || !compareArgs(fieldArgs, args)) {\n        continue;\n      }\n\n      const page = getPage(cache, entityKey, fieldKey);\n      if (page === null) {\n        continue;\n      }\n\n      if (\n        mergeMode === 'inwards' &&\n        typeof args.last === 'number' &&\n        typeof args.first === 'number'\n      ) {\n        const firstEdges = page.edges.slice(0, args.first + 1);\n        const lastEdges = page.edges.slice(-args.last);\n\n        startEdges = concatEdges(cache, startEdges, firstEdges);\n        endEdges = concatEdges(cache, lastEdges, endEdges);\n\n        pageInfo = page.pageInfo;\n      } else if (args.after) {\n        startEdges = concatEdges(cache, startEdges, page.edges);\n        pageInfo.endCursor = page.pageInfo.endCursor;\n        pageInfo.hasNextPage = page.pageInfo.hasNextPage;\n      } else if (args.before) {\n        endEdges = concatEdges(cache, page.edges, endEdges);\n        pageInfo.startCursor = page.pageInfo.startCursor;\n        pageInfo.hasPreviousPage = page.pageInfo.hasPreviousPage;\n      } else if (typeof args.last === 'number') {\n        endEdges = concatEdges(cache, endEdges, page.edges);\n        pageInfo = page.pageInfo;\n      } else {\n        startEdges = concatEdges(cache, startEdges, page.edges);\n        pageInfo = page.pageInfo;\n      }\n\n      if (page.pageInfo.__typename !== pageInfo.__typename)\n        pageInfo.__typename = page.pageInfo.__typename;\n      if (typename !== page.__typename) typename = page.__typename;\n    }\n\n    if (typeof typename !== 'string') {\n      return undefined;\n    }\n\n    const hasCurrentPage = !!ensureKey(\n      cache.resolve(entityKey, fieldName, fieldArgs)\n    );\n    if (!hasCurrentPage) {\n      if ((info as any).schemaPredicates === undefined) {\n        return undefined;\n      } else {\n        info.partial = true;\n      }\n    }\n\n    return {\n      __typename: typename,\n      edges:\n        mergeMode === 'inwards'\n          ? concatEdges(cache, startEdges, endEdges)\n          : concatEdges(cache, endEdges, startEdges),\n      pageInfo: {\n        __typename: pageInfo.__typename,\n        endCursor: pageInfo.endCursor,\n        startCursor: pageInfo.startCursor,\n        hasNextPage: pageInfo.hasNextPage,\n        hasPreviousPage: pageInfo.hasPreviousPage,\n      },\n    };\n  };\n};\n","import { stringifyVariables } from 'urql/core';\nimport { Resolver, Variables, NullArray } from '../types';\n\nexport interface PaginationParams {\n  offsetArgument?: string;\n  limitArgument?: string;\n}\n\nexport const simplePagination = ({\n  offsetArgument = 'skip',\n  limitArgument = 'limit',\n}: PaginationParams = {}): Resolver => {\n  const compareArgs = (\n    fieldArgs: Variables,\n    connectionArgs: Variables\n  ): boolean => {\n    for (const key in connectionArgs) {\n      if (key === offsetArgument || key === limitArgument) {\n        continue;\n      } else if (!(key in fieldArgs)) {\n        return false;\n      }\n\n      const argA = fieldArgs[key];\n      const argB = connectionArgs[key];\n\n      if (\n        typeof argA !== typeof argB || typeof argA !== 'object'\n          ? argA !== argB\n          : stringifyVariables(argA) !== stringifyVariables(argB)\n      ) {\n        return false;\n      }\n    }\n\n    for (const key in fieldArgs) {\n      if (key === offsetArgument || key === limitArgument) {\n        continue;\n      }\n      if (!(key in connectionArgs)) return false;\n    }\n\n    return true;\n  };\n\n  return (_parent, fieldArgs, cache, info) => {\n    const { parentKey: entityKey, fieldName } = info;\n\n    const allFields = cache.inspectFields(entityKey);\n    const fieldInfos = allFields.filter(info => info.fieldName === fieldName);\n    const size = fieldInfos.length;\n    if (size === 0) {\n      return undefined;\n    }\n\n    const visited = new Set();\n    let result: NullArray<string> = [];\n    let prevOffset: number | null = null;\n\n    for (let i = 0; i < size; i++) {\n      const { fieldKey, arguments: args } = fieldInfos[i];\n      if (args === null || !compareArgs(fieldArgs, args)) {\n        continue;\n      }\n\n      const links = cache.resolveFieldByKey(entityKey, fieldKey) as string[];\n      const currentOffset = args[offsetArgument];\n\n      if (\n        links === null ||\n        links.length === 0 ||\n        typeof currentOffset !== 'number'\n      ) {\n        continue;\n      }\n\n      if (!prevOffset || currentOffset > prevOffset) {\n        for (let j = 0; j < links.length; j++) {\n          const link = links[j];\n          if (visited.has(link)) continue;\n          result.push(link);\n          visited.add(link);\n        }\n      } else {\n        const tempResult: NullArray<string> = [];\n        for (let j = 0; j < links.length; j++) {\n          const link = links[j];\n          if (visited.has(link)) continue;\n          tempResult.push(link);\n          visited.add(link);\n        }\n        result = [...tempResult, ...result];\n      }\n\n      prevOffset = currentOffset;\n    }\n\n    const hasCurrentPage = cache.resolve(entityKey, fieldName, fieldArgs);\n    if (hasCurrentPage) {\n      return result;\n    } else if ((info as any).schemaPredicates === undefined) {\n      return undefined;\n    } else {\n      info.partial = true;\n      return result;\n    }\n  };\n};\n"],"names":["const","defaultPageInfo","__typename","endCursor","startCursor","hasNextPage","hasPreviousPage","ensureKey","x","concatEdges","cache","leftEdges","rightEdges","ids","Set","i","l","node","newEdges","edge","compareArgs","fieldArgs","connectionArgs","key","argA","argB","stringifyVariables","getPage","entityKey","fieldKey","link","typename","edges","pageInfo","pageInfoKey","pageInfoType","page","params","mergeMode","_parent","info","fieldInfos","fieldName","size","startEdges","endEdges","args","firstEdges","lastEdges","undefined","ref","offsetArgument","limitArgument","visited","result","prevOffset","links","currentOffset","j","tempResult"],"mappings":"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"}